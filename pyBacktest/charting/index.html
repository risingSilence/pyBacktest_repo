<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>M1/Mx Dynamic Viewer – Regime Logic (Anchored)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

    <link rel="stylesheet" href="hide_axis_cover.css" />
    <script src="axis_keyboard.js"></script>
    <script src="crosshair_labels.js"></script>
    <script src="timeframe_keyboard.js"></script>

    <style>
        body {
            margin: 0;
            padding: 8px;
            font-family: Arial, sans-serif;
            background: #ffffff;
            color: #000;
        }

        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px 16px;
            align-items: center;
            margin-bottom: 8px;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .toolbar-section label {
            font-size: 12px;
            font-weight: bold;
        }

        .tf-select {
            font-size: 12px;
            padding: 2px 4px;
        }

        .tf-radio-group,
        #axis-mode {
            font-size: 12px;
        }

        #axis-mode label {
            margin-right: 8px;
        }

        #m1-chart {
            height: 85vh;
        }

        /* Damit lange Dateinamen nicht das Layout sprengen, geben wir max-width */
        #phase2-file-select, #phase3-file-select {
            max-width: 300px;
            text-overflow: ellipsis;
        }

        .hint {
            font-size: 12px;
            color: #555;
            margin-bottom: 4px;
        }

        #chart-splitter {
            position: relative;
            flex: 0 0 3px;        /* Layout-Breite bleibt 3px */
            cursor: col-resize;
            background: transparent;
            z-index: 10;          /* WICHTIG: über den Charts liegen */
        }

        /* Unsichtbare, überlappende Hitbox: 18px breit, zentriert */
        #chart-splitter::before {
            content: "";
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 18px;          /* 9px links + 9px rechts */
            height: 100%;
            cursor: inherit;      /* col-resize übernehmen */
            /* kein background -> komplett transparent */
        }
    </style>
</head>
<body>

    <h3>M1/Mx Dynamic Viewer (NY Time, Regime Logic, Anchored)</h3>

    <div class="toolbar">
        <div class="toolbar-section" id="htf-tf-section" style="display:none;">
            <label for="tf-select-left">HTF:</label>
            <select id="tf-select-left" class="tf-select">
                </select>
        </div>

        <div class="toolbar-section" id="ltf-tf-section">
            <label for="tf-select">Timeframe:</label>
            <select id="tf-select" class="tf-select">
                </select>
        </div>

        <div class="toolbar-section">
            <label>
                <input type="checkbox" id="candle-hover-toggle" />
                Candle Info Box
            </label>
            <label style="margin-left:12px;">
                <input type="checkbox" id="show-misses-toggle" checked />
                Show Misses
            </label>
            <label style="margin-left:12px;">
                <input type="checkbox" id="show-signals-toggle" checked />
                Show Signals
            </label>
        </div>

        <div class="toolbar-section">
            <label>View:</label>
            <div id="view-mode">
                <label>
                    <input type="radio" name="view-mode" value="single" checked />
                    One&nbsp;Window
                </label>
                <label>
                    <input type="radio" name="view-mode" value="split" />
                    HTF&nbsp;/&nbsp;LTF
                </label>
            </div>
        </div>

        <div class="toolbar-section">
            <label for="htf-behavior-select" style="font-size:12px; font-weight:bold;">
                HTF behavior:
            </label>
            <select
                id="htf-behavior-select"
                style="font-size:12px; padding:2px 4px; min-width:260px;"
            >
                <option value="independent_snapshots">HTF independent + setup snapshots</option>
                <option value="follow_ltf_snapshots">HTF follows LTF + setup snapshots</option>
                <option value="follow_ltf_strict">HTF follows LTF strictly</option>
            </select>
        </div>


        <div class="toolbar-section">
            <label for="session-days">Session Days:</label>
            <input
                type="number"
                id="session-days"
                min="0"
                max="60"
                value="10"
                style="width: 60px; font-size: 12px; padding: 2px 4px;"
            />
        </div>

        <div class="toolbar-section">
            <div style="display:flex; flex-wrap:wrap; gap:8px;">
                <div>
                    <label for="phase2-file-select" style="font-size:12px; font-weight:bold;">
                        Phase 2 Setups:
                    </label>
                    <select id="phase2-file-select" style="font-size:12px; padding:2px 4px; min-width:220px; max-width:400px;">
                        </select>
                </div>
                <div>
                    <label for="phase3-file-select" style="font-size:12px; font-weight:bold;">
                        Phase 3 Trades:
                    </label>
                    <select id="phase3-file-select" style="font-size:12px; padding:2px 4px; min-width:240px; max-width:400px;">
                        </select>
                </div>

                <div>
                    <label for="setup-select" style="font-size:12px; font-weight:bold;">
                        Setup Selection:
                    </label>
                    <select
                        id="setup-select"
                        style="
                            font-size:12px;
                            padding:2px 4px;
                            min-width:280px;
                            font-family:'Courier New', monospace;
                            white-space:pre;
                        "
                    >
                        </select>
                </div>

                <div>
                    <label for="setup-sort-select" style="font-size:12px; font-weight:bold;">
                        Sorting:
                    </label>
                    <select
                        id="setup-sort-select"
                        style="font-size:12px; padding:2px 4px; min-width:220px;"
                    >
                        <option value="time_asc">Time: Old ↑, New ↓</option>
                        <option value="time_desc">Time: New ↑, Old ↓</option>
                        <option value="dir_long_short">Directional: Longs first</option>
                        <option value="dir_short_long">Directional: Shorts first</option>
                        <option value="r_desc">Winners first</option>
                        <option value="r_asc">Losers first</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <div class="hint">
        Mouse wheel = Zoom/Pan (X &amp; Y). Shift + Scroll/Drag = X only. Alt + Scroll/Drag = Y only.
    </div>

    <div id="chart-container" style="display:flex; gap:0;">
        <div id="left-chart-wrapper" style="flex:1 1 50%; display:none;">
            <div id="htf-chart" style="height:85vh;"></div>
        </div>

        <div
            id="chart-splitter"
            style="
                flex:0 0 3px;
                cursor: col-resize;
                background: transparent;
                display:none; /* nur im Split-View sichtbar */
            "
        ></div>

        <div id="right-chart-wrapper" style="flex:1 1 100%;">
            <div id="m1-chart" style="height:85vh;"></div>
        </div>
    </div>

    <script>
        // -----------------------------------------------------------
        // 1) Globale State-Variablen & Regime-Definition
        // -----------------------------------------------------------
        const TF_LIST = ["M1", "M3", "M5", "M15", "H1", "H4", "D", "W", "M"];
        const REGIME_OF_TF = {
            M1: "minute",
            M3: "minute",
            M5: "minute",
            M15: "minute",
            H1: "hourly",
            H4: "hourly",
            D: "daily",
            W: "daily",
            M: "daily",
        };

        let DATA = null;          // { symbol, timeframes: {tf: {bars: [...], minIdx, maxIdx}} }
        let currentTf = "M5";
        // Linker (HTF) Chart
        let currentTfLeft = "H1";

        let candleHoverOn = false;
        let axisMode = "both";

        const DEFAULT_SESSION_DAYS = 10;
        const NBSP = "\u00A0";  // non-breaking space für Dropdown-Alignment

        let sessionDays = DEFAULT_SESSION_DAYS;
        let SHOW_MISSES = true;
        let SHOW_SIGNALS = true;

        const VIEW_MODE_SINGLE = "single";
        const VIEW_MODE_SPLIT  = "split";
        let VIEW_MODE = VIEW_MODE_SINGLE;   // default: One Window

        const HTF_BEHAVIOR_INDEPENDENT   = "independent_snapshots";
        const HTF_BEHAVIOR_FOLLOW_SNAP   = "follow_ltf_snapshots";
        const HTF_BEHAVIOR_FOLLOW_STRICT = "follow_ltf_strict";
        let HTF_BEHAVIOR = HTF_BEHAVIOR_INDEPENDENT;  // Default = bisheriges Verhalten


        // Verhältnis der Breite: wie viel Prozent bekommt der linke Chart im Split-View?
        // 0.5 = 50/50, wird bei Drag aktualisiert und persistiert.
        let SPLIT_LEFT_FRACTION = 0.5;

        // Splitter-Drag-State (zwischen linkem und rechtem Chart)
        let isSplitterDragging = false;
        let splitterStartX = 0;
        let splitterStartLeftWidth = 0;
        let splitterStartRightWidth = 0;
        let splitterContainerWidth = 0;
        let splitterWidthPx = 0;

        // Session-Definitionen (NY-"Naivzeit" wie deine Bars)
        // Farben exakt aus deinen PNGs, mit 90% Transparenz (alpha = 0.1)
        // Hex -> rgba:
        // Asia      #4DD0E1 -> rgba(77, 208, 225, 0.1)
        // London    #4CAF50 -> rgba(76, 175, 80, 0.1)
        // Frankfurt #FF9800 -> rgba(255, 152, 0, 0.1)
        // New York  #AB47BC -> rgba(171, 71, 188, 0.1)
        //
        // startOffsetDays / endOffsetDays sind relativ zur "Trading-Date" (NY Handelstag),
        // also zu dem Tag, dessen Sessions von Asia 20:00 (Vortag) bis NY 12:00 laufen.
        const SESSION_CONFIG = [
            {
                id: "asia",
                name: "Asia",
                startOffsetDays: -1,      // Vortag 20:00
                startHour: 20,
                startMinute: 0,
                endOffsetDays: 0,         // Handelstag 01:00
                endHour: 1,
                endMinute: 0,
                fillColor: "rgba(77, 208, 225, 0.1)"   // #4DD0E1
            },
            {
                id: "frankfurt",
                name: "Frankfurt",
                startOffsetDays: 0,
                startHour: 1,
                startMinute: 45,
                endOffsetDays: 0,
                endHour: 2,
                endMinute: 45,
                fillColor: "rgba(255, 152, 0, 0.1)"    // #FF9800
            },
            {
                id: "london",
                name: "London",
                startOffsetDays: 0,
                startHour: 3,
                startMinute: 0,
                endOffsetDays: 0,
                endHour: 7,
                endMinute: 0,
                fillColor: "rgba(76, 175, 80, 0.1)"    // #4CAF50
            },
            {
                id: "newyork",
                name: "New York",
                startOffsetDays: 0,
                startHour: 8,
                startMinute: 0,
                endOffsetDays: 0,
                endHour: 12,
                endMinute: 0,
                fillColor: "rgba(171, 71, 188, 0.1)"   // #AB47BC
            }
        ];

        // Phase2/Phase3: Datenverzeichnis (wie im alten Python: data/*.csv)
        const DATA_DIR_URL = "data/";

        // Auto-Scan-Intervall (wie dcc.Interval: 5000 ms)
        const PHASE_FILE_SCAN_INTERVAL_MS = 1000;

        // Aktuelle Datei-Listen (werden durch Scan gefüllt)
        let phase2Files = [];   // ["EURUSD_setups.csv", ...]
        let phase3Files = [];   // ["EURUSD_trades_2024.csv", ...]

        // Aktuell ausgewählte Datei-Namen (nur der Dateiname, ohne Pfad)
        let phase2File = null;
        let phase3File = null;

        let PHASE2_BOXES = [];   // [{ direction, topTs, bottomTs }, ...]
        let PHASE3_TRADES = [];  // [{ ... }] (inkl. entryPrice/slPrice/tpPrice/...)

        // Setups für den neuen Umschalter
        let SETUPS = [];        // flache Liste aller Setups (aus Phase2+Phase3 gemerged)
        let SETUP_BY_ID = {};   // id -> Setup-Objekt
        let SETUP_SORT_MODE = "time_asc";

        // Snapshot-State für den HTF-Chart (linke Seite)
        let HTF_SNAPSHOT_ACTIVE = false;
        let HTF_SNAPSHOT_INFO = null;      // { tf, setupId, signalTs, snapshotTime, htfBarIndex, ltfSignalIdx }
        let HTF_SNAPSHOT_TFDATA = null;    // temporäre, gekappte + aggregierte HTF-Daten

        // Fortlaufender HTF-Follow-Snapshot (Aggregierung zum rechten LTF-Rand)
        let HTF_FOLLOW_ACTIVE = false;
        let HTF_FOLLOW_TFDATA = null;      // gekappte + aggregierte HTF-Daten (Follow)
        let HTF_FOLLOW_INFO   = null;      // { tf, snapshotTime, htfBarIndex }

        // Fingerprints für Change-Detection
        let lastPhase2File = null;
        let lastPhase2Text = null;
        let lastPhase3File = null;
        let lastPhase3Text = null;

        // Timer-Handle für das regelmäßige Scannen/Laden
        let phaseScanTimer = null;




        const DEFAULT_VISIBLE_BARS = 400;
        const BUFFER_FACTOR = 3.0;   // totalBars ≈ visibleBars * BUFFER_FACTOR

        // tf -> {windowStart, windowEnd, visibleStartIdx, visibleEndIdx, visibleBars, minIdx, maxIdx}
        const TF_STATE = {};
        // tf -> State (linker Chart)
        const TF_STATE_LEFT = {};

        // regime -> { initialized, timeRange: [t0, t1], yRange: [y0, y1], anchorTime: t1, visibleBarsHint: number }
        const REGIME_STATE = {
            minute: { initialized: false, timeRange: null, yRange: null, anchorTime: null, visibleBarsHint: null },
            hourly: { initialized: false, timeRange: null, yRange: null, anchorTime: null, visibleBarsHint: null },
            daily:  { initialized: false, timeRange: null, yRange: null, anchorTime: null, visibleBarsHint: null },
        };

        // regime -> State (linker Chart)
        const REGIME_STATE_LEFT = {
            minute: { initialized: false, timeRange: null, yRange: null, anchorTime: null, visibleBarsHint: null },
            hourly: { initialized: false, timeRange: null, yRange: null, anchorTime: null, visibleBarsHint: null },
            daily:  { initialized: false, timeRange: null, yRange: null, anchorTime: null, visibleBarsHint: null },
        };

        // --- Persistenz (localStorage) ---
        const STORAGE_KEY = "m1_mx_dynamic_viewer_state_v1";

        // Auto-Save global steuern (alter + neuer Tab)
        let AUTO_SAVE_ENABLED = true;

        function savePersistentState() {
            if (!AUTO_SAVE_ENABLED || !window.localStorage || !DATA) return;
                const payload = {
                currentTf,
                currentTfLeft,
                axisMode,
                candleHoverOn,
                sessionDays,
                REGIME_STATE,
                REGIME_STATE_LEFT,
                TF_STATE,
                TF_STATE_LEFT,
                SHOW_MISSES,
                SHOW_SIGNALS,
                SETUP_SORT_MODE,
                VIEW_MODE,
                htfBehavior: HTF_BEHAVIOR,
                splitterLeftFraction: SPLIT_LEFT_FRACTION
            };
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
            } catch (e) {
                console.warn("Could not save viewer state:", e);
            }
        }

        function restorePersistentState() {
            if (!window.localStorage || !DATA) return false;

            let raw;
            try {
                raw = localStorage.getItem(STORAGE_KEY);
            } catch (e) {
                console.warn("Could not read viewer state:", e);
                return false;
            }
            if (!raw) return false;

            let saved;
            try {
                saved = JSON.parse(raw);
            } catch (e) {
                console.warn("Viewer state corrupt, ignoring:", e);
                return false;
            }

            // aktuelles Timeframe
            if (saved.currentTf && saved.currentTf in (DATA.timeframes || {})) {
                currentTf = saved.currentTf;
            }

            // aktuelles Timeframe (linker Chart)
            if (saved.currentTfLeft && saved.currentTfLeft in (DATA.timeframes || {})) {
                currentTfLeft = saved.currentTfLeft;
            }

            // Candle-Hover
            if (typeof saved.candleHoverOn === "boolean") {
                candleHoverOn = saved.candleHoverOn;
            }

            // Axis-Mode: UI ist entfernt, Basis-Modus immer "both"
            axisMode = "both";

            // Session-Tage
            if (typeof saved.sessionDays === "number" && saved.sessionDays >= 0) {
                sessionDays = saved.sessionDays;
            }

            // Show Misses
            if (typeof saved.SHOW_MISSES === "boolean") {
                SHOW_MISSES = saved.SHOW_MISSES;
            }

            // Show Signals
            if (typeof saved.SHOW_SIGNALS === "boolean") {
                SHOW_SIGNALS = saved.SHOW_SIGNALS;
            }

            // Setup-Sortierung
            if (typeof saved.SETUP_SORT_MODE === "string") {
                SETUP_SORT_MODE = saved.SETUP_SORT_MODE;
            }

            // View-Mode
            if (typeof saved.VIEW_MODE === "string") {
                if (saved.VIEW_MODE === VIEW_MODE_SINGLE || saved.VIEW_MODE === VIEW_MODE_SPLIT) {
                    VIEW_MODE = saved.VIEW_MODE;
                }
            }

            // HTF-Behavior
            if (typeof saved.htfBehavior === "string") {
                if (
                    saved.htfBehavior === HTF_BEHAVIOR_INDEPENDENT ||
                    saved.htfBehavior === HTF_BEHAVIOR_FOLLOW_SNAP ||
                    saved.htfBehavior === HTF_BEHAVIOR_FOLLOW_STRICT
                ) {
                    HTF_BEHAVIOR = saved.htfBehavior;
                }
            }

            // Splitter-Position (links/rechts Verhältnis)
            if (typeof saved.splitterLeftFraction === "number" && isFinite(saved.splitterLeftFraction)) {
                // leicht clampen, damit nichts komplett verschwindet
                SPLIT_LEFT_FRACTION = Math.min(0.9, Math.max(0.1, saved.splitterLeftFraction));
            }

            // Regime-State mergen
            if (saved.REGIME_STATE) {
                for (const [key, val] of Object.entries(saved.REGIME_STATE)) {
                    if (REGIME_STATE[key]) {
                        Object.assign(REGIME_STATE[key], val);
                    }
                }
            }

            // Regime-State mergen (linker Chart)
            if (saved.REGIME_STATE_LEFT) {
                for (const [key, val] of Object.entries(saved.REGIME_STATE_LEFT)) {
                    if (REGIME_STATE_LEFT[key]) {
                        Object.assign(REGIME_STATE_LEFT[key], val);
                    }
                }
            }

            // TF-State mergen
            if (saved.TF_STATE) {
                for (const [tf, tfState] of Object.entries(saved.TF_STATE)) {
                    TF_STATE[tf] = { ...tfState };
                }
            }

            // TF-State mergen (linker Chart)
            if (saved.TF_STATE_LEFT) {
                for (const [tf, tfState] of Object.entries(saved.TF_STATE_LEFT)) {
                    TF_STATE_LEFT[tf] = { ...tfState };
                }
            }

            return true;
        }

        function reapplyStateFromStorage() {
            const ok = restorePersistentState();
            if (!ok) {
                console.warn("[restart] reapplyStateFromStorage: restorePersistentState() failed");
                return;
            }

            if (!DATA || !DATA.timeframes || !DATA.timeframes[currentTf]) {
                console.warn("[restart] reapplyStateFromStorage: no data for currentTf");
                return;
            }

            // Right TF Fallback
            if (!DATA.timeframes[currentTf]) {
                const available = Object.keys(DATA.timeframes);
                if (available.length > 0) {
                    currentTf = available[0];
                }
            }
            // Left TF Fallback
            if (!DATA.timeframes[currentTfLeft]) {
                const available = Object.keys(DATA.timeframes);
                if (available.length > 0) {
                    currentTfLeft = available[0];
                }
            }

            // Rechter Chart
            const tfDataR = DATA.timeframes[currentTf];
            let stateR = TF_STATE[currentTf];
            if (!stateR) {
                stateR = computeWindowForTf(tfDataR, DEFAULT_VISIBLE_BARS, tfDataR.maxIdx);
            }
            const regimeR = getRegime(currentTf);
            const regStateR = REGIME_STATE[regimeR] || {};

            applyStateAndRender(currentTf, stateR, {
                autoY: false,
                yRangeOverride: regStateR.yRange
            });

            // Linker Chart (nur wenn Split-Mode)
            if (VIEW_MODE === VIEW_MODE_SPLIT && DATA.timeframes[currentTfLeft]) {
                const tfDataL = DATA.timeframes[currentTfLeft];
                let stateL = TF_STATE_LEFT[currentTfLeft];
                if (!stateL) {
                    stateL = computeWindowForTf(tfDataL, DEFAULT_VISIBLE_BARS, tfDataL.maxIdx);
                }
                const regimeL = getRegime(currentTfLeft, "left");
                const regStateL = REGIME_STATE_LEFT[regimeL] || {};

                applyStateAndRenderLeft(currentTfLeft, stateL, {
                    autoY: false,
                    yRangeOverride: regStateL.yRange
                });
            }

            // UI-Controls syncen
            if (typeof syncUiToState === "function") {
                syncUiToState();
            }

            updateLayoutForViewMode();
        }

        const PLOT_CONFIG = {
            displaylogo: false,
            scrollZoom: true,
            responsive: true
        };

        const BACKGROUND_COLOR = "rgb(255,255,255)";
        const FOREGROUND_COLOR = "rgb(0,0,0)";
        const WICK_OUTLINE_COLOR = "rgb(19,23,34)";
        const BULL_BODY_COLOR = "rgb(144,191,249)";
        const BEAR_BODY_COLOR = "rgb(178,181,190)";

        // geschätzte halbe Body-Breite einer Candle in X-Koordinaten
        // (du nutzt aktuell 0.5 für "Candlegap-Mitte bis Candlegap-Mitte")
        const CANDLE_BODY_HALF_WIDTH = 0.5;

        // Phase-2 Basis-TF (aus Dateinamen) + entsprechende Minuten
        // Beispiel: "data_EURUSD_M5_phase2_setups.csv" -> M5 -> 5 Minuten
        let PHASE2_SIGNAL_BASE_TF = null;
        let PHASE2_SIGNAL_BASE_MINUTES = 5;   // Default, falls nichts erkannt wird

        // Referenz-TF für die Y-Range der Boxen (z.B. M5, abgeleitet aus PHASE2_SIGNAL_BASE_TF)
        let PHASE2_BASE_TF = null;

        // Zeitgrenze für den HTF-Snapshot:
        // Close-Zeit der aktuell gewählten Setup-Signalkerze.
        // Wird in focusOnSetup() gesetzt und in clearHtfSnapshot() wieder auf null gesetzt.
        let HTF_SNAPSHOT_MAX_SIGNAL_TS = null;

        let isRelayoutFromCode = false;
        let plotlyEventsBound = false;

        // -----------------------------------------------------------
        // 2) Helper
        // -----------------------------------------------------------

        // Prüft, ob Kerzen im sichtbaren X-Bereich vertikal komplett außerhalb des Y-Views liegen.
        // Falls ja, wird ein korrigierter Y-Range zurückgegeben (Pan ohne Zoom).
        function calculateVerticalCorrection(tfData, visibleStartIdx, visibleEndIdx, currentYRange) {
            if (!tfData || !tfData.bars || visibleStartIdx == null || visibleEndIdx == null || !currentYRange) {
                return null;
            }

            const yMin = currentYRange[0];
            const yMax = currentYRange[1];

            // Nichts tun, wenn Y ungültig ist
            if (!Number.isFinite(yMin) || !Number.isFinite(yMax) || yMax <= yMin) {
                return null;
            }

            // 1. Extremwerte im sichtbaren Bereich finden
            // Wir iterieren direkt über die Indizes, um slice-Overhead zu sparen
            const bars = tfData.bars;
            const maxDataIdx = tfData.maxIdx;
            const minDataIdx = tfData.minIdx;

            // Index-Grenzen auf Daten limitieren
            let start = Math.max(minDataIdx, Math.round(visibleStartIdx));
            let end   = Math.min(maxDataIdx, Math.round(visibleEndIdx));
            
            // Umrechnung von Bar-Index 'i' auf Array-Index
            // Da wir wissen, dass i kontinuierlich sein könnte, aber minIdx offset hat:
            // Sicherer Weg: via binärer Suche Start finden oder (wenn lückenlos) rechnen.
            // Da deine Bars 'i' properties haben, nutzen wir findPos...Logik oder iterieren kurz.
            // Da bars meist sortiert sind:
            
            // Optimierung: sliceBarsForRange nutzen (existiert bereits im Code)
            const visibleBars = sliceBarsForRange(tfData, start, end);

            if (!visibleBars || !visibleBars.length) {
                return null; // Keine Daten im sichtbaren Bereich -> keine Korrektur möglich
            }

            let globalHigh = Number.NEGATIVE_INFINITY;
            let globalLow  = Number.POSITIVE_INFINITY;

            for (const bar of visibleBars) {
                if (bar.h > globalHigh) globalHigh = bar.h;
                if (bar.l < globalLow)  globalLow  = bar.l;
            }

            if (!Number.isFinite(globalHigh) || !Number.isFinite(globalLow)) {
                return null;
            }

            const height = yMax - yMin;
            const padding = height * 0.10; // 10% Abstand

            // FALL A: Alle Kerzen liegen ÜBER dem sichtbaren Bereich
            // Logik: Wir pannen hoch. Die tiefste Kerze (globalLow) soll unten erscheinen (+10% Padding).
            // Neuer yMin = globalLow - padding
            if (globalLow > yMax) {
                const newYMin = globalLow - padding;
                const newYMax = newYMin + height;
                console.log("[AutoPan] Candles above view -> Correction Up applied.");
                return [newYMin, newYMax];
            }

            // FALL B: Alle Kerzen liegen UNTER dem sichtbaren Bereich
            // Logik: Wir pannen runter. Die höchste Kerze (globalHigh) soll oben erscheinen (-10% Padding).
            // Neuer yMax = globalHigh + padding
            if (globalHigh < yMin) {
                const newYMax = globalHigh + padding;
                const newYMin = newYMax - height;
                console.log("[AutoPan] Candles below view -> Correction Down applied.");
                return [newYMin, newYMax];
            }

            // Fall C: Kerzen sind (teilweise) sichtbar -> keine Korrektur
            return null;
        }

        // Helper: TF -> Minuten
        function tfToMinutes(tf) {
            switch (tf) {
                case "M1":  return 1;
                case "M3":  return 3;
                case "M5":  return 5;
                case "M15": return 15;
                case "H1":  return 60;
                case "H4":  return 240;
                case "D":   return 1440;
                case "W":   return 10080;
                case "M":   return 43200; // grob: 30 Tage
                default:    return null;
            }
        }

        // Helper: aus Dateinamen wie "EURUSD_M5_phase2_setups.csv"
        // den Basis-TF der Phase-2-Signale ziehen.
        function updatePhase2SignalBaseFromFilename(filename) {
            // Defaults
            PHASE2_SIGNAL_BASE_TF = null;
            PHASE2_SIGNAL_BASE_MINUTES = 5;
            PHASE2_BASE_TF = null;   // erzwingt Re-Auswahl im getPhase2BaseTfData

            if (!filename) return;

            const lower = filename.toUpperCase();
            let detectedTf = null;

            // TF_LIST ist global definiert: ["M1","M3","M5","M15","H1","H4","D","W","M"]
            for (const tf of TF_LIST) {
                const token = "_" + tf.toUpperCase() + "_";
                if (lower.includes(token)) {
                    detectedTf = tf;
                    break;
                }
            }

            if (!detectedTf) {
                console.warn("[Phase2] Could not derive TF from filename:", filename);
                return;
            }

            PHASE2_SIGNAL_BASE_TF = detectedTf;
            const mins = tfToMinutes(detectedTf);
            if (mins != null) {
                PHASE2_SIGNAL_BASE_MINUTES = mins;
            }

            console.log(
                "[Phase2] Signal-Base-TF:",
                PHASE2_SIGNAL_BASE_TF,
                "(" + PHASE2_SIGNAL_BASE_MINUTES + " min) from",
                filename
            );
        }

        // NEU: getRegime akzeptiert jetzt 'pane' ("left" oder "right")
        function getRegime(tf, pane = "right") {
            // Exception: M15 im HTF (links) -> Hourly Regime
            if (tf === "M15" && pane === "left") {
                return "hourly";
            }
            return REGIME_OF_TF[tf] || "minute";
        }

        // Dauer eines Bars je Timeframe in Millisekunden (für Snapshot-Berechnungen)
        function timeframeToMs(tf) {
            if (!tf) return null;
            switch (tf) {
                case "M1":  return 1 * 60 * 1000;
                case "M3":  return 3 * 60 * 1000;
                case "M5":  return 5 * 60 * 1000;
                case "M15": return 15 * 60 * 1000;
                case "H1":  return 60 * 60 * 1000;
                case "H4":  return 4 * 60 * 60 * 1000;
                case "D":   return 24 * 60 * 60 * 1000;
                case "W":   return 7 * 24 * 60 * 60 * 1000;
                case "M":   return 30 * 24 * 60 * 60 * 1000; // grobe Approximation
                default:
                    return null;
            }
        }

        // --- Date/Time Helper für Sessions (UTC-basierte NY-"Naivzeit") ---

        function pad2(n) {
            return String(n).padStart(2, "0");
        }

        function dateKeyFromDate(dt) {
            const y = dt.getUTCFullYear();
            const m = pad2(dt.getUTCMonth() + 1);
            const d = pad2(dt.getUTCDate());
            return `${y}-${m}-${d}`;
        }

        function dateFromKey(key) {
            const parts = key.split("-");
            if (parts.length !== 3) return null;
            const y = parseInt(parts[0], 10);
            const m = parseInt(parts[1], 10);
            const d = parseInt(parts[2], 10);
            if (!y || !m || !d) return null;
            return new Date(Date.UTC(y, m - 1, d));
        }

        function addDaysUtc(date, days) {
            const d = new Date(date.getTime());
            d.setUTCDate(d.getUTCDate() + days);
            return d;
        }

        // NY-Trading-Day-Key: Handelstag von 17:00 (Vortag) bis 17:00
        // Beispiel: 20:30 (Asia) am 13. -> Trading-Day 14.
        //           08:15 (NY) am 14.    -> Trading-Day 14.
        function tradingDateKeyFromDate(dt) {
            const h = dt.getUTCHours();
            const base = (h >= 17) ? addDaysUtc(dt, 1) : dt;
            return dateKeyFromDate(base);
        }



        // NY-naive ISO (z.B. "2025-10-31T16:59:00") als "UTC-Schiene" interpretieren
        function parseNyIsoToMs(isoStr) {
            if (!isoStr) return NaN;
            if (!isoStr.endsWith("Z")) {
                isoStr += "Z";
            }
            return Date.parse(isoStr);
        }

        // NY-naiver Zeitstring aus CSV (mit " " ODER "T" zwischen Datum/Zeit)
        // wird genauso behandelt wie t in data.json: naive NY -> als UTC interpretiert.
        function parseNyStringToMs(str) {
            if (!str) return NaN;
            let iso = String(str).trim();
            if (!iso) return NaN;

            // "2025-10-31 16:59:00" -> "2025-10-31T16:59:00"
            if (iso.indexOf("T") === -1 && iso.indexOf(" ") !== -1) {
                iso = iso.replace(" ", "T");
            }

            if (!iso.endsWith("Z")) {
                iso += "Z";
            }
            const ts = Date.parse(iso);
            return Number.isNaN(ts) ? NaN : ts;
        }


        // -----------------------------------------------------------
        // CSV-Parsing für Phase2/Phase3
        // -----------------------------------------------------------

        function parseCsvToObjects(text) {
            const lines = text.split(/\r?\n/).filter(line => line.trim() !== "");
            if (!lines.length) return [];
            const header = lines[0].split(",").map(h => h.trim());
            const rows = [];
            for (let i = 1; i < lines.length; i++) {
                const parts = lines[i].split(",");
                if (!parts.length) continue;
                const obj = {};
                header.forEach((h, idx) => {
                    obj[h] = (parts[idx] !== undefined) ? parts[idx].trim() : "";
                });
                rows.push(obj);
            }
            return rows;
        }

        function buildPhase2BoxesFromRows(rows) {
            const boxes = [];

            rows.forEach((row, rowIndex) => {
                const directionRaw = row["direction"] || "";
                const direction = directionRaw.toLowerCase();
                const dateNy = row["date_ny"] || row["date"] || "";

                const hod_time = parseNyStringToMs(row["hod_time"]);
                const ll2_time = parseNyStringToMs(row["ll2_time"]);
                const lod_time = parseNyStringToMs(row["lod_time"]);
                const hh2_time = parseNyStringToMs(row["hh2_time"]);

                let topTs = NaN;
                let bottomTs = NaN;
                let signalTs = NaN;

                if (
                    direction === "sell" &&
                    !Number.isNaN(hod_time) &&
                    !Number.isNaN(ll2_time)
                ) {
                    // SELL: Box HOD -> LL2, Signal = LL2
                    topTs = hod_time;
                    bottomTs = ll2_time;
                    signalTs = ll2_time;
                } else if (
                    direction === "buy" &&
                    !Number.isNaN(lod_time) &&
                    !Number.isNaN(hh2_time)
                ) {
                    // BUY: Box LOD -> HH2, Signal = HH2
                    topTs = hh2_time;
                    bottomTs = lod_time;
                    signalTs = hh2_time;
                } else {
                    // unvollständiger Setup -> überspringen
                    return;
                }

                boxes.push({
                    direction,         // "buy" / "sell"
                    topTs,
                    bottomTs,
                    signalTs,          // Ende der Phase2-Box (Signalkerze)
                    dateNy,            // z.B. "2024-02-07"
                    setupIndex: rowIndex
                });
            });

            // für den alten Code: weiterhin nach Zeit sortieren
            boxes.sort((a, b) => a.topTs - b.topTs);
            return boxes;
        }

        function findPhase2BoxForTrade(trade) {
            if (!PHASE2_BOXES || !PHASE2_BOXES.length) return null;

            // 1) Versuch: exakter setup_index
            if (trade.setupIndex != null) {
                const byIdx = PHASE2_BOXES.find(
                    (b) => b.setupIndex === trade.setupIndex
                );
                if (byIdx) return byIdx;
            }

            // 2) Fallback: date_ny + direction
            if (trade.dateNy) {
                const matches = PHASE2_BOXES.filter(
                    (b) => b.dateNy === trade.dateNy && b.direction === trade.direction
                );
                if (matches.length === 1) return matches[0];
                if (matches.length > 1) return matches[0]; // notfalls erster Treffer
            }

            return null;
        }

        function buildSetupLabel(direction, signalTs, dateNy, achievedR, isMissed, isBreakeven) {
            // BUY/SELL einheitlich auf 4 Zeichen (z.B. "BUY·" / "SELL"), mit NBSP als Füller
            const dirBase = (direction === "buy") ? "BUY" : "SELL";
            const dirCol = (dirBase + NBSP.repeat(4)).slice(0, 4);

            // Datum + Uhrzeit aus signalTs
            let datePart = "??.??.?? ??:??";
            if (signalTs != null && Number.isFinite(signalTs)) {
                const dt = new Date(signalTs);
                const dd = String(dt.getUTCDate()).padStart(2, "0");
                const mm = String(dt.getUTCMonth() + 1).padStart(2, "0");
                const yy = String(dt.getUTCFullYear()).slice(-2);
                const hh = String(dt.getUTCHours()).padStart(2, "0");
                const mi = String(dt.getUTCMinutes()).padStart(2, "0");
                // zwischen Datum und Uhrzeit nur ein normales Space
                datePart = `${dd}.${mm}.${yy} ${hh}:${mi}`;
            } else if (dateNy) {
                const parts = dateNy.split("-");
                if (parts.length === 3) {
                    const yy = parts[0].slice(-2);
                    const mm = parts[1];
                    const dd = parts[2];
                    datePart = `${dd}.${mm}.${yy} 00:00`;
                }
            }

            // Achieved R / Miss-Label
            let rStr;
            if (isMissed) {
                // Misses: "··miss" (2 NBSP vor "miss")
                rStr = NBSP + NBSP + "miss";
            } else {
                let rVal = achievedR;
                if (!Number.isFinite(rVal)) rVal = 0;
                const sign = (rVal >= 0 ? "+" : "");
                rStr = `${sign}${rVal.toFixed(2)}R`;
            }

            // Rechtsblock auf Länge 6 bringen, mit NBSP auffüllen
            if (rStr.length < 6) {
                rStr = NBSP.repeat(6 - rStr.length) + rStr;
            }

            // Spacing:
            // dirCol (4) + 3x NBSP + datePart + 4x NBSP + rStr
            // → BUY/SELL-Spalte bündig, Datum+Zeit bündig, R/miss bündig
            const gapDirDate = NBSP.repeat(3);
            const gapDateR   = NBSP.repeat(4);

            return `${dirCol}${gapDirDate}${datePart}${gapDateR}${rStr}`;
        }

        function getSortedSetups() {
            const list = SETUPS.slice();

            list.sort(function (a, b) {
                // Standard: time_asc
                if (SETUP_SORT_MODE === "time_asc") {
                    return (a.signalTs || 0) - (b.signalTs || 0);
                }

                if (SETUP_SORT_MODE === "time_desc") {
                    return (b.signalTs || 0) - (a.signalTs || 0);
                }

                if (SETUP_SORT_MODE === "dir_long_short") {
                    // Longs oben (neu -> alt), Shorts unten (neu -> alt)
                    if (a.direction !== b.direction) {
                        if (a.direction === "buy") return -1;
                        if (b.direction === "buy") return 1;
                    }
                    return (b.signalTs || 0) - (a.signalTs || 0);
                }

                if (SETUP_SORT_MODE === "dir_short_long") {
                    // Shorts oben (neu -> alt), Longs unten (neu -> alt)
                    if (a.direction !== b.direction) {
                        if (a.direction === "sell") return -1;
                        if (b.direction === "sell") return 1;
                    }
                    return (b.signalTs || 0) - (a.signalTs || 0);
                }

                if (SETUP_SORT_MODE === "r_desc") {
                    // Winners zuerst: R absteigend, Misses immer ganz zum Schluss
                    const am = !!a.isMissed;
                    const bm = !!b.isMissed;
                    if (am !== bm) return am ? 1 : -1; // Misses unten

                    const ra = Number.isFinite(a.achievedR) ? a.achievedR : 0;
                    const rb = Number.isFinite(b.achievedR) ? b.achievedR : 0;
                    if (rb !== ra) return rb - ra;
                    return (a.signalTs || 0) - (b.signalTs || 0);
                }

                if (SETUP_SORT_MODE === "r_asc") {
                    // Losers zuerst: R aufsteigend, Misses immer ganz zum Schluss
                    const am = !!a.isMissed;
                    const bm = !!b.isMissed;
                    if (am !== bm) return am ? 1 : -1; // Misses unten

                    const ra = Number.isFinite(a.achievedR) ? a.achievedR : 0;
                    const rb = Number.isFinite(b.achievedR) ? b.achievedR : 0;
                    if (ra !== rb) return ra - rb;
                    return (a.signalTs || 0) - (b.signalTs || 0);
                }

                // Fallback: time_asc
                return (a.signalTs || 0) - (b.signalTs || 0);
            });

            return list;
        }

        function renderSetupDropdown() {
            const select = document.getElementById("setup-select");
            if (!select) return;

            const prevValue = select.value;

            // Dropdown leeren
            select.innerHTML = "";

            // Platzhalter (leer, nicht auswählbar, nicht sichtbar im Menü)
            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.disabled = true;
            placeholder.selected = true;
            placeholder.hidden = true;
            select.appendChild(placeholder);

            if (!SETUPS || !SETUPS.length) {
                return;
            }

            const sorted = getSortedSetups();

            // Mapping id -> Setup neu aufbauen
            SETUP_BY_ID = {};
            for (const s of sorted) {
                SETUP_BY_ID[String(s.id)] = s;
            }

            sorted.forEach((setup) => {
                const opt = document.createElement("option");
                opt.value = String(setup.id);
                opt.textContent = setup.label;
                select.appendChild(opt);
            });

            // previous selection wiederherstellen, falls noch vorhanden
            if (prevValue && SETUP_BY_ID[prevValue]) {
                select.value = prevValue;
            } else {
                select.value = "";
            }
        }

        function rebuildSetupsList() {
            SETUPS = [];
            SETUP_BY_ID = {};

            if (!PHASE3_TRADES || !PHASE3_TRADES.length || !PHASE2_BOXES || !PHASE2_BOXES.length) {
                renderSetupDropdown();
                return;
            }

            let idCounter = 0;

            for (const tr of PHASE3_TRADES) {
                // zugehörige Phase2-Box finden
                const box = findPhase2BoxForTrade(tr);
                if (!box || !Number.isFinite(box.signalTs)) continue;

                const direction = tr.direction || box.direction || "buy";
                const signalTs = box.signalTs;
                const dateNy = tr.dateNy || box.dateNy || "";

                const rawR = (typeof tr.resultR === "number" && !Number.isNaN(tr.resultR)) ? tr.resultR : 0;
                const isMissed = !tr.filled;
                const isBreakeven = tr.filled && Math.abs(rawR) < 1e-6;

                // "Show Misses" Filter
                if (isMissed && !SHOW_MISSES) {
                    continue;
                }

                const achievedR = rawR;
                const label = buildSetupLabel(direction, signalTs, dateNy, achievedR, isMissed, isBreakeven);

                SETUPS.push({
                    id: idCounter++,
                    direction,
                    signalTs,
                    dateNy,
                    achievedR,
                    isMissed,
                    isBreakeven,
                    boxRef: box,
                    tradeRef: tr,
                    label
                });
            }

            renderSetupDropdown();
        }

        function focusOnSetup(setup) {
            if (!setup) return;
            if (!DATA || !DATA.timeframes || !DATA.timeframes[currentTf]) return;

            // Snapshot-Zeit nur in Modi mit Setup-Snapshots merken
            if (
                HTF_BEHAVIOR === HTF_BEHAVIOR_INDEPENDENT ||
                HTF_BEHAVIOR === HTF_BEHAVIOR_FOLLOW_SNAP
            ) {
                if (setup.signalTs != null && Number.isFinite(setup.signalTs)) {
                    HTF_SNAPSHOT_MAX_SIGNAL_TS =
                        setup.signalTs + PHASE2_SIGNAL_BASE_MINUTES * 60 * 1000;
                } else {
                    HTF_SNAPSHOT_MAX_SIGNAL_TS = null;
                }
            } else {
                HTF_SNAPSHOT_MAX_SIGNAL_TS = null;
            }

            const tfData = DATA.timeframes[currentTf];
            const regime = getRegime(currentTf);
            const regState = REGIME_STATE[regime] || {};

            // ---------- X-Achse: zentrieren auf 10:00 NY des Setup-Tages ----------
            let anchorTs = null;
            if (setup.dateNy) {
                // statisch 10:00 wie gewünscht
                anchorTs = parseNyStringToMs(`${setup.dateNy} 10:00:00`);
            } else if (setup.signalTs != null && Number.isFinite(setup.signalTs)) {
                anchorTs = setup.signalTs;
            }

            let anchorPos = null;
            if (anchorTs != null && Number.isFinite(anchorTs)) {
                anchorPos = findPosLEByTs(tfData, anchorTs);
                if (anchorPos === null) anchorPos = findPosGEByTs(tfData, anchorTs);
            }

            if (anchorPos === null) {
                // Fallback: letzte Bar
                anchorPos = tfData.bars.length - 1;
            }

            const anchorIdx = tfData.bars[anchorPos].i;

            // aktuelle Zoombreite behalten
            let state = TF_STATE[currentTf];
            if (!state) {
                state = computeWindowForTf(tfData, DEFAULT_VISIBLE_BARS, tfData.maxIdx);
            }
            const visibleBars = state.visibleBars || DEFAULT_VISIBLE_BARS;

            const newState = computeWindowForTf(tfData, visibleBars, anchorIdx);

            // ---------- Y-Achse: Abstand 100px relativ zur Setup-Box (nicht Tages-HOD/LOD) ----------

            // Basis-yRange = aktueller Regime-Range (damit "Zoom" gleich bleibt)
            let yRange = regState.yRange;
            if (!yRange) {
                // Fallback: einmal Auto-Y für dieses Fenster berechnen
                const tmp = buildFigureForState(currentTf, tfData, newState, null, true, "right");
                yRange = tmp.usedYRange;
            }

            if (!yRange || yRange.length !== 2) {
                // wenn alles schiefgeht -> einfach Auto-Y
                applyStateAndRender(currentTf, newState, { autoY: true });
                return;
            }

            let yMin = yRange[0];
            let yMax = yRange[1];
            let h = yMax - yMin;
            if (!(h > 0)) {
                applyStateAndRender(currentTf, newState, { autoY: true });
                return;
            }

            const chartEl = document.getElementById("m1-chart");
            const rect = chartEl ? chartEl.getBoundingClientRect() : null;
            const plotHeight = (rect && rect.height) ? rect.height : 600; // Fallback

            const pxOffset = 100;
            const pricePerPx = h / plotHeight;
            const delta = pricePerPx * pxOffset;

            // LOD/HOD nur in Bezug auf die Setup-Box bestimmen
            let lod = Number.POSITIVE_INFINITY;
            let hod = Number.NEGATIVE_INFINITY;

            const box = setup.boxRef; // kommt aus rebuildSetupsList()
            if (box && Number.isFinite(box.topTs) && Number.isFinite(box.bottomTs)) {
                const tMin = Math.min(box.topTs, box.bottomTs);
                const tMax = Math.max(box.topTs, box.bottomTs);

                const bars = tfData.bars || [];
                for (const bar of bars) {
                    if (bar.ts < tMin) continue;
                    if (bar.ts > tMax) break;
                    if (bar.l < lod) lod = bar.l;
                    if (bar.h > hod) hod = bar.h;
                }
            }

            // Fallback: falls irgendwas bei der Box schiefgeht, wieder auf Tageslogik zurückfallen
            if (!Number.isFinite(lod) || !Number.isFinite(hod)) {
                const targetKey = setup.dateNy;
                lod = Number.POSITIVE_INFINITY;
                hod = Number.NEGATIVE_INFINITY;

                if (targetKey) {
                    for (const bar of tfData.bars) {
                        const dt = new Date(bar.ts);
                        const key = tradingDateKeyFromDate(dt);
                        if (key !== targetKey) continue;
                        if (bar.l < lod) lod = bar.l;
                        if (bar.h > hod) hod = bar.h;
                    }
                }
            }

            let newYMin = yMin;
            let newYMax = yMax;

            if (setup.direction === "buy" && lod < Number.POSITIVE_INFINITY) {
                // LOD der Setup-Box soll 100px über dem unteren Rand liegen
                newYMin = lod - delta;
                newYMax = newYMin + h;
            } else if (setup.direction === "sell" && hod > Number.NEGATIVE_INFINITY) {
                // HOD der Setup-Box soll 100px unter dem oberen Rand liegen
                newYMax = hod + delta;
                newYMin = newYMax - h;
            }

            const newYRange = [newYMin, newYMax];

            applyStateAndRender(currentTf, newState, {
                autoY: false,
                yRangeOverride: newYRange
            });

            // Setup-Snapshot nur in Modi, die Snapshots erlauben
            if (
                VIEW_MODE === VIEW_MODE_SPLIT &&
                (HTF_BEHAVIOR === HTF_BEHAVIOR_INDEPENDENT ||
                 HTF_BEHAVIOR === HTF_BEHAVIOR_FOLLOW_SNAP)
            ) {
                applyHtfSnapshotForSetup(setup);
            } else {
                clearHtfSnapshot();
            }
        }

        // Liefert die sichtbare Mitte einer Phase2-Box im aktuellen TF,
        // begrenzt auf den sichtbaren Datenbereich [visibleStartIdx, visibleEndIdx].
        function getBoxVisibleCenterIndexInTf(tfData, box, visibleStartIdx, visibleEndIdx) {
            if (!tfData || !tfData.bars || !tfData.bars.length || !box) return null;

            const t1 = box.topTs;
            const t2 = box.bottomTs;
            if (!Number.isFinite(t1) || !Number.isFinite(t2)) return null;

            const startTs = Math.min(t1, t2);
            const endTs   = Math.max(t1, t2);

            // Ende der Box: komplette Signalkerze berücksichtigen (wie beim Zeichnen)
            let effectiveEndTs = endTs;
            if (Number.isFinite(endTs) && PHASE2_SIGNAL_BASE_MINUTES > 1) {
                effectiveEndTs = endTs + (PHASE2_SIGNAL_BASE_MINUTES - 1) * 60 * 1000;
            }

            let posL = findPosLEByTs(tfData, startTs);
            let posR = findPosLEByTs(tfData, effectiveEndTs);

            if (posL === null) posL = 0;
            if (posR === null) posR = tfData.bars.length - 1;
            if (posR < posL) {
                const tmp = posL;
                posL = posR;
                posR = tmp;
            }

            const idxL = tfData.bars[posL].i;
            const idxR = tfData.bars[posR].i;

            // Schneide auf den sichtbaren Datenbereich zu
            const left  = Math.max(idxL, visibleStartIdx);
            const right = Math.min(idxR, visibleEndIdx);
            if (right < left) return null;

            const center = 0.5 * (left + right);
            return { idxL, idxR, left, right, center };
        }

        // Sucht im aktuellen LTF das "beste" Setup für den angegebenen View-State:
        // - Box muss den sichtbaren Datenbereich schneiden
        // - möglichst nah an der View-Mitte
        // - bei Gleichstand gewinnt das rechtere (größerer Center-Index)
        // Gibt nur das Setup zurück, ändert NICHT die UI.
        function autoSelectSetupForCurrentView(tfData, state, excludedSetupId) {
            if (!SETUPS || !SETUPS.length) return null;
            if (!tfData || !tfData.bars || !tfData.bars.length) return null;
            if (!state || state.visibleStartIdx == null || state.visibleEndIdx == null) return null;

            const vs = state.visibleStartIdx;
            const ve = state.visibleEndIdx;
            const viewCenter = 0.5 * (vs + ve);

            let bestSetup = null;
            let bestCenter = null;
            let bestScore = null;

            for (const setup of SETUPS) {
                if (excludedSetupId != null && setup.id === excludedSetupId) continue;

                const box = setup.boxRef;
                if (!box) continue;

                const info = getBoxVisibleCenterIndexInTf(tfData, box, vs, ve);
                if (!info) continue; // Box schneidet den sichtbaren Bereich nicht

                const center = info.center;
                const score = Math.abs(center - viewCenter);  // Distanz zur View-Mitte

                if (bestSetup === null) {
                    bestSetup = setup;
                    bestCenter = center;
                    bestScore = score;
                } else {
                    if (score < bestScore - 1e-6) {
                        bestSetup = setup;
                        bestCenter = center;
                        bestScore = score;
                    } else if (Math.abs(score - bestScore) <= 1e-6) {
                        // Gleichstand → rechter (größerer Index) gewinnt
                        if (center > bestCenter) {
                            bestSetup = setup;
                            bestCenter = center;
                            bestScore = score;
                        }
                    }
                }
            }

            return bestSetup;
        }

        function clearHtfSnapshot(options) {
            const opts = options || {};
            const clearSetupSelect = !!opts.clearSetupSelect;

            // NEU: Marker an allen Phase2-Boxen zurücksetzen
            if (PHASE2_BOXES && PHASE2_BOXES.length) {
                for (const box of PHASE2_BOXES) {
                    box.isSnapshotActive = false;
                }
            }

            HTF_SNAPSHOT_ACTIVE = false;
            HTF_SNAPSHOT_MAX_SIGNAL_TS = null;
            HTF_SNAPSHOT_TFDATA = null;
            HTF_SNAPSHOT_INFO = null;

            if (clearSetupSelect) {
                const setupSelectEl = document.getElementById("setup-select");
                if (setupSelectEl) {
                    setupSelectEl.value = "";
                }
            }
        }

        // Baut aus dem Original-HTF + M1-Daten einen gekappten HTF-Datensatz
        // mit einer partiell aggregierten letzten Candle (bis snapshotTimeMs).
        function buildHtfSnapshotData(tfName, tfDataOriginal, m1Data, snapshotTimeMs) {
            if (!tfDataOriginal || !tfDataOriginal.bars || !tfDataOriginal.bars.length) return null;
            if (!m1Data || !m1Data.bars || !m1Data.bars.length) return null;
            if (!isFinite(snapshotTimeMs)) return null;

            // HTF-Bar finden, deren Zeitraum snapshotTime abdeckt (via ts <= snapshotTime)
            let pos = findPosLEByTs(tfDataOriginal, snapshotTimeMs);
            if (pos === null) return null;

            const barsOrig = tfDataOriginal.bars;
            const htfBar = barsOrig[pos];
            const htfOpenTs = htfBar.ts;

            const m1BarsAll = m1Data.bars;

            // M1-Range: [HTF-Open, snapshotTime)
            const startTs = htfOpenTs;
            const endTs = snapshotTimeMs;

            let posStart = findPosGEByTs(m1Data, startTs);
            let posEnd = findPosLEByTs(m1Data, endTs - 1);

            // Wenn wir keine passenden M1-Daten finden, nutzen wir die Original-HTF-Bar
            if (posStart === null || posEnd === null || posEnd < posStart) {
                const snapshotBarsFallback = barsOrig.slice(0, pos + 1).map(b => ({ ...b }));
                const lastFallback = snapshotBarsFallback[snapshotBarsFallback.length - 1];

                return {
                    htfSnapshotData: {
                        ...tfDataOriginal,
                        bars: snapshotBarsFallback,
                        maxIdx: lastFallback.i
                    },
                    htfBarIndex: lastFallback.i
                };
            }

            // Aggregation aus M1: Open = erste M1, Close = letzte M1,
            // High/Low = Extremwerte über den ganzen Bereich inkl. letzter Candle.
            let o = m1BarsAll[posStart].o;
            let h = m1BarsAll[posStart].h;
            let l = m1BarsAll[posStart].l;
            let c = m1BarsAll[posEnd].c;

            for (let i = posStart; i <= posEnd; i++) {
                const b = m1BarsAll[i];
                if (b.h > h) h = b.h;
                if (b.l < l) l = b.l;
            }

            // Original-Bars bis inkl. dieser HTF-Bar kopieren
            const snapshotBars = barsOrig.slice(0, pos + 1).map(b => ({ ...b }));
            const last = snapshotBars[snapshotBars.length - 1];
            last.o = o;
            last.h = h;
            last.l = l;
            last.c = c;

            return {
                htfSnapshotData: {
                    ...tfDataOriginal,
                    bars: snapshotBars,
                    maxIdx: last.i
                },
                htfBarIndex: last.i
            };
        }

        // Baut und aktiviert den HTF-Snapshot für ein bestimmtes Setup
        function applyHtfSnapshotForSetup(setup, options) {
            const opts = options || {};
            
            // Standard: false (snappen), außer es wird explizit true übergeben
            let shouldPreserveView = !!opts.preserveView;
            
            // Neu: Kennzeichnung, ob der Aufruf durch Pannen (Auto) oder User (Klick) kam
            const isAutoPan = !!opts.isAutoPan;

            // In strikt folgendem Modus keine Setup-Snapshots
            if (HTF_BEHAVIOR === HTF_BEHAVIOR_FOLLOW_STRICT) {
                return;
            }

            if (!DATA || !DATA.timeframes || !setup) {
                clearHtfSnapshot();
                return;
            }

            // Marker resetten
            if (PHASE2_BOXES && PHASE2_BOXES.length) {
                for (const box of PHASE2_BOXES) {
                    box.isSnapshotActive = false;
                }
            }
            if (setup.boxRef) {
                setup.boxRef.isSnapshotActive = true;
            }

            if (VIEW_MODE !== VIEW_MODE_SPLIT) {
                clearHtfSnapshot();
                return;
            }

            const tfLeft = currentTfLeft;
            const tfDataLeft = DATA.timeframes[tfLeft];
            const m1Data = DATA.timeframes["M1"];
            const tfDataLtf = DATA.timeframes[currentTf]; 

            if (!tfDataLeft || !m1Data || !tfDataLtf) {
                clearHtfSnapshot();
                return;
            }

            const ltfDurationMs = timeframeToMs(currentTf);
            if (!ltfDurationMs || !isFinite(setup.signalTs)) {
                clearHtfSnapshot();
                return;
            }

            const snapshotTime = setup.signalTs + ltfDurationMs;
            const snapshot = buildHtfSnapshotData(tfLeft, tfDataLeft, m1Data, snapshotTime);
            if (!snapshot) {
                clearHtfSnapshot();
                return;
            }

            const { htfSnapshotData, htfBarIndex } = snapshot;

            let ltfSignalIdx = null;
            const ltfPos = findPosLEByTs(tfDataLtf, setup.signalTs);
            if (ltfPos !== null) {
                ltfSignalIdx = tfDataLtf.bars[ltfPos].i;
            }

            HTF_SNAPSHOT_ACTIVE = true;
            HTF_SNAPSHOT_TFDATA = htfSnapshotData;
            HTF_SNAPSHOT_INFO = {
                tf: tfLeft,
                setupId: setup.id,
                signalTs: setup.signalTs,
                snapshotTime,
                htfBarIndex,
                ltfSignalIdx
            };

            const regimeLeft = getRegime(tfLeft, "left");
            const regStateLeft = REGIME_STATE_LEFT[regimeLeft] || {};

            // -------------------------------------------------------
            // SMART SNAP LOGIK
            // Nur anwenden, wenn preserveView NICHT erzwungen ist UND es ein Auto-Pan ist!
            // Wenn der User klickt (isAutoPan = false), wird dieser Block übersprungen 
            // und wir landen unten beim "Standard-Snap".
            // -------------------------------------------------------
            if (!shouldPreserveView && isAutoPan) {
                const stateLeft = TF_STATE_LEFT[tfLeft];
                if (stateLeft && stateLeft.viewEnd != null && stateLeft.visibleStartIdx != null && stateLeft.visibleEndIdx != null) {
                    // Wie viel Platz ist aktuell rechts vom neuen Daten-Ende?
                    const currentGap = stateLeft.viewEnd - (htfBarIndex + 0.5);
                    
                    // Wie groß sind 10% der aktuellen Breite?
                    const currentWidth = stateLeft.visibleEndIdx - stateLeft.visibleStartIdx;
                    const minRequiredGap = Math.max(1, currentWidth * 0.1);

                    // Wenn wir bereits MEHR als 10% Platz haben, brauchen wir nicht snappen!
                    if (currentGap >= minRequiredGap) {
                        shouldPreserveView = true;
                    }
                }
            }

            // 🔹 FALL 1: View beibehalten (User wollte preserve ODER AutoPan war happy mit dem Platz)
            if (shouldPreserveView) {
                let stateLeft = TF_STATE_LEFT[tfLeft];
                if (stateLeft) {
                    stateLeft = { ...stateLeft };

                    const minIdx = htfSnapshotData.minIdx;
                    const maxIdx = htfSnapshotData.maxIdx;

                    if (typeof minIdx === "number" && typeof maxIdx === "number") {
                        if (stateLeft.visibleStartIdx < minIdx) stateLeft.visibleStartIdx = minIdx;
                        if (stateLeft.visibleEndIdx > maxIdx) stateLeft.visibleEndIdx = maxIdx;

                        if (stateLeft.visibleEndIdx < stateLeft.visibleStartIdx) {
                            stateLeft.visibleStartIdx = Math.max(minIdx, maxIdx - DEFAULT_VISIBLE_BARS);
                            stateLeft.visibleEndIdx = maxIdx;
                        }
                        
                        stateLeft.windowStart = Math.max(minIdx, stateLeft.visibleStartIdx - 100);
                        stateLeft.windowEnd   = Math.min(maxIdx, stateLeft.visibleEndIdx + 100);
                    }

                    applyStateAndRenderLeft(tfLeft, stateLeft, {
                        autoY: false,
                        yRangeOverride: regStateLeft.yRange
                    });
                    return;
                }
            }

            // 🔹 FALL 2: Standard-Snap (Dropdown, Hotkey ODER AutoPan mit zu wenig Platz)
            // Hier wird immer neu rechtsbündig ausgerichtet.
            let stateLeft = TF_STATE_LEFT[tfLeft];
            let visibleBars = DEFAULT_VISIBLE_BARS;
            if (stateLeft && isFinite(stateLeft.visibleBars) && stateLeft.visibleBars > 0) {
                visibleBars = stateLeft.visibleBars;
            }

            const newState = computeWindowForTfRightAnchored(
                htfSnapshotData,
                visibleBars,
                htfBarIndex
            );

            // Gap berechnen (10%)
            const span = Math.max(1, newState.visibleEndIdx - newState.visibleStartIdx + 1);
            const gapBars = Math.max(1, Math.round(span * 0.1)); 

            newState.viewStart = newState.visibleStartIdx - 0.5;
            newState.viewEnd   = newState.visibleEndIdx + 0.5 + gapBars;

            // Y-Range zentrieren
            let baseYRange = regStateLeft.yRange;
            let height = null;
            if (baseYRange && baseYRange.length === 2) {
                height = baseYRange[1] - baseYRange[0];
            }
            const lastBar = htfSnapshotData.bars.find(b => b.i === htfBarIndex) || htfSnapshotData.bars[htfSnapshotData.bars.length - 1];
            let newYRange = null;
            if (lastBar && height && height > 0) {
                const center = 0.5 * (lastBar.h + lastBar.l);
                if (isFinite(center)) {
                    newYRange = [center - height / 2, center + height / 2];
                }
            }

            applyStateAndRenderLeft(tfLeft, newState, {
                autoY: !newYRange,
                yRangeOverride: newYRange || baseYRange || null
            });
        }

        // Hilfsfunktion: erste vorhandene numerische Spalte aus einer Kandidatenliste holen
        function pickNumberField(row, candidates) {
            for (const name of candidates) {
                if (name in row && row[name] !== "") {
                    const v = parseFloat(String(row[name]).replace(",", "."));
                    if (!Number.isNaN(v)) return v;
                }
            }
            return NaN;
        }

        // Phase3: Trades aus *_trades_*.csv
        // Wir verwenden hier nur entry_idx / exit_idx (wie im Python),
        // die Preise holen wir später aus den OHLC-Daten.
        function buildPhase3TradesFromRows(rows) {
            const trades = [];

            for (const row of rows) {
                const direction = (row["direction"] || "").toLowerCase();
                const dateNy = row["date_ny"] || row["date"] || "";
                const symbol = row["symbol"] || "";
                const scenarioId = row["scenario_id"] || "";
                const exitMode = row["exit_mode"] || "";
                const missReason = row["miss_reason"] || "";

                const filledRaw = (row["filled"] || "").toLowerCase();
                const filled =
                    filledRaw === "true" ||
                    filledRaw === "1" ||
                    filledRaw === "yes";

                let setupIndex = NaN;
                if (row["setup_index"] !== undefined && row["setup_index"] !== "") {
                    const tmp = parseInt(row["setup_index"], 10);
                    if (!Number.isNaN(tmp)) setupIndex = tmp;
                }

                const entryTsRaw = parseNyStringToMs(row["entry_idx"]);
                const exitTsRaw = parseNyStringToMs(row["exit_idx"]);

                const hasEntryTs = !Number.isNaN(entryTsRaw);
                const hasExitTs = !Number.isNaN(exitTsRaw);

                // Preise aus möglichen Spalten ziehen (wie vorher)
                const entryPrice = pickNumberField(row, [
                    "entry_price",
                    "entry",
                    "entry_px",
                    "entry_close",
                ]);

                const slPrice = pickNumberField(row, [
                    "sl_price",
                    "sl",
                    "stop_price",
                    "stop",
                ]);

                const tpPrice = pickNumberField(row, [
                    "tp_price",
                    "tp",
                    "target_price",
                    "target",
                ]);

                const exitPrice = pickNumberField(row, [
                    "exit_price",
                    "exit",
                    "exit_px",
                    "exit_close",
                ]);

                // R-Ergebnis (kann leer sein)
                let resultR = NaN;
                if (row["result_R"] !== undefined && row["result_R"] !== "") {
                    const tmpR = parseFloat(String(row["result_R"]).replace(",", "."));
                    if (!Number.isNaN(tmpR)) resultR = tmpR;
                }

                // Nur echte Fills verlangen zwingend einen Entry+Exit
                if (filled && (!hasEntryTs || !hasExitTs)) {
                    // unvollständige Daten -> überspringen
                    continue;
                }

                // Limit-Ablauf: erstmal fix auf 12:00 NY des date_ny
                let entryWindowEndTs = null;
                if (dateNy) {
                    const ts = parseNyStringToMs(`${dateNy} 12:00:00`);
                    if (!Number.isNaN(ts)) entryWindowEndTs = ts;
                }

                trades.push({
                    direction,
                    symbol,
                    dateNy,
                    scenarioId,
                    exitMode,
                    missReason,
                    setupIndex: Number.isNaN(setupIndex) ? null : setupIndex,
                    filled,

                    entryTs: hasEntryTs ? entryTsRaw : null,
                    exitTs: hasExitTs ? exitTsRaw : null,
                    entryWindowEndTs, // Ende des Entry-Fensters (12:00)

                    entryPrice: Number.isNaN(entryPrice) ? NaN : entryPrice,
                    slPrice: Number.isNaN(slPrice) ? NaN : slPrice,
                    tpPrice: Number.isNaN(tpPrice) ? NaN : tpPrice,
                    exitPrice: Number.isNaN(exitPrice) ? NaN : exitPrice,

                    resultR: Number.isNaN(resultR) ? null : resultR
                });
            }

            // Sortierung: erst nach "Startzeit" (Entry, sonst Fenster-Ende)
            trades.sort((a, b) => {
                const ta =
                    (a.entryTs != null ? a.entryTs : a.entryWindowEndTs) ?? 0;
                const tb =
                    (b.entryTs != null ? b.entryTs : b.entryWindowEndTs) ?? 0;
                return ta - tb;
            });

            return trades;
        }

        // -----------------------------------------------------------
        // Dateien laden: Phase2 / Phase3
        // -----------------------------------------------------------

        // Liefert true zurück, wenn sich die Phase2-Daten wirklich geändert haben
        async function loadPhase2File(filename) {
            let changed = false;

            if (!filename) {
                // Auswahl geleert -> ggf. vorhandene Daten zurücksetzen
                if (PHASE2_BOXES.length || lastPhase2File !== null || lastPhase2Text !== null) {
                    PHASE2_BOXES = [];
                    lastPhase2File = null;
                    lastPhase2Text = null;
                    changed = true;
                }
                // auch Signal-Basis-TF zurücksetzen
                updatePhase2SignalBaseFromFilename(null);
                return changed;
            }

            // NEU: Basis-TF/-Minuten aus dem Dateinamen ableiten
            updatePhase2SignalBaseFromFilename(filename);

            const url = DATA_DIR_URL + filename;
            try {
                const res = await fetch(url, { cache: "no-store" });
                if (!res.ok) {
                    console.warn("[Phase2] Could not load file:", url, res.status);
                    // Wenn vorher etwas da war, jetzt aber nicht mehr -> als Änderung zählen
                    if (PHASE2_BOXES.length || lastPhase2File !== filename || lastPhase2Text !== null) {
                        PHASE2_BOXES = [];
                        lastPhase2File = filename;
                        lastPhase2Text = null;
                        changed = true;
                    }
                    return changed;
                }

                const text = await res.text();

                // Fingerprint vergleichen: gleicher File-Name + identischer Text?
                if (lastPhase2File === filename && lastPhase2Text === text) {
                    // Nichts geändert
                    return false;
                }

                const rows = parseCsvToObjects(text);
                const newBoxes = buildPhase2BoxesFromRows(rows);

                PHASE2_BOXES = newBoxes;
                lastPhase2File = filename;
                lastPhase2Text = text;
                changed = true;

            } catch (e) {
                console.warn("[Phase2] Error loading:", url, e);
                if (PHASE2_BOXES.length || lastPhase2File !== filename || lastPhase2Text !== null) {
                    PHASE2_BOXES = [];
                    lastPhase2File = filename;
                    lastPhase2Text = null;
                    changed = true;
                }
            }

            return changed;
        }


        // Liefert true zurück, wenn sich die Phase3-Daten wirklich geändert haben
        async function loadPhase3File(filename) {
            let changed = false;

            if (!filename) {
                if (PHASE3_TRADES.length || lastPhase3File !== null || lastPhase3Text !== null) {
                    PHASE3_TRADES = [];
                    lastPhase3File = null;
                    lastPhase3Text = null;
                    changed = true;
                }
                return changed;
            }

            const url = DATA_DIR_URL + filename;
            try {
                const res = await fetch(url, { cache: "no-store" });
                if (!res.ok) {
                    console.warn("[Phase3] Could not load file:", url, res.status);
                    if (PHASE3_TRADES.length || lastPhase3File !== filename || lastPhase3Text !== null) {
                        PHASE3_TRADES = [];
                        lastPhase3File = filename;
                        lastPhase3Text = null;
                        changed = true;
                    }
                    return changed;
                }

                const text = await res.text();

                if (lastPhase3File === filename && lastPhase3Text === text) {
                    return false;
                }

                const rows = parseCsvToObjects(text);
                const newTrades = buildPhase3TradesFromRows(rows);

                PHASE3_TRADES = newTrades;
                lastPhase3File = filename;
                lastPhase3Text = text;
                changed = true;

            } catch (e) {
                console.warn("[Phase3] Error loading:", url, e);
                if (PHASE3_TRADES.length || lastPhase3File !== filename || lastPhase3Text !== null) {
                    PHASE3_TRADES = [];
                    lastPhase3File = filename;
                    lastPhase3Text = null;
                    changed = true;
                }
            }

            return changed;
        }

        function buildTfSelects() {
            const tfSelect = document.getElementById("tf-select");
            const tfSelectLeft = document.getElementById("tf-select-left");
            if (!tfSelect || !tfSelectLeft) return;

            // Dropdowns leeren
            tfSelect.innerHTML = "";
            tfSelectLeft.innerHTML = "";

            // Filter Definitionen
            const invalidForLtf = ["W", "M"];           // LTF: kein Weekly/Monthly
            const invalidForHtf = ["M1", "M3", "M5"];   // HTF: nichts unter 15min

            // Optionen füllen
            TF_LIST.forEach((tf) => {
                // 1. Rechter Chart (LTF / Main)
                if (!invalidForLtf.includes(tf)) {
                    const optMain = document.createElement("option");
                    optMain.value = tf;
                    optMain.textContent = tf;
                    if (tf === currentTf) optMain.selected = true;
                    tfSelect.appendChild(optMain);
                }

                // 2. Linker Chart (HTF)
                if (!invalidForHtf.includes(tf)) {
                    const optLeft = document.createElement("option");
                    optLeft.value = tf;
                    optLeft.textContent = tf;
                    if (tf === currentTfLeft) optLeft.selected = true;
                    tfSelectLeft.appendChild(optLeft);
                }
            });

            // Event: rechter Chart (LTF)
            tfSelect.addEventListener("change", (e) => {
                const newTf = e.target.value;
                if (newTf && newTf !== currentTf) {
                    onTfChange(newTf);
                    savePersistentState();
                }
            });

            // Event: linker Chart (HTF)
            tfSelectLeft.addEventListener("change", (e) => {
                const newTf = e.target.value;
                if (newTf && newTf !== currentTfLeft) {
                    onTfChangeLeft(newTf);
                    savePersistentState();
                }
            });
        }

        // -----------------------------------------------------------
        // 3) Daten laden
        // -----------------------------------------------------------
        async function loadData() {
            const response = await fetch("data.json");
            if (!response.ok) {
                throw new Error("Could not load data.json: " + response.statusText);
            }
            // ... (Rest von loadData bleibt gleich, siehe vorheriger Output)
            const payload = await response.json();
            // ... (Schleifenlogik bleibt gleich) ...
            for (const [tf, tfData] of Object.entries(payload.timeframes)) {
                 // ... (etc)
                 // (Da sich hier nur der Error-Text ändert, kürze ich ab – nimm deinen bestehenden Body und ändere nur den Error String oben)
                 // Falls du unsicher bist, sag Bescheid, dann paste ich loadData nochmal komplett.
                 // Hier der Vollständigkeit halber der Loop-Start für den Kontext:
                 const bars = tfData.bars || [];
                 if (!bars.length) continue;
                 
                 for (const bar of bars) {
                     bar.ts = parseNyIsoToMs(bar.t);
                 }
                 tfData.minIdx = bars[0].i;
                 tfData.maxIdx = bars[bars.length - 1].i;
                 
                 const yearFirstTradingDate = {};
                 const monthFirstTradingDate = {};
                 for (const bar of bars) {
                     const dt = new Date(bar.ts);
                     const y = dt.getUTCFullYear();
                     const m = dt.getUTCMonth() + 1;
                     const d = dt.getUTCDate();
                     const wd = dt.getUTCDay();
                     if (wd === 6) continue;
                     const mStr = String(m).padStart(2, "0");
                     const dStr = String(d).padStart(2, "0");
                     const dateKey = `${y}-${mStr}-${dStr}`;
                     const ymKey = `${y}-${mStr}`;
                     if (yearFirstTradingDate[y] === undefined) {
                         yearFirstTradingDate[y] = dateKey;
                     }
                     if (monthFirstTradingDate[ymKey] === undefined) {
                         monthFirstTradingDate[ymKey] = dateKey;
                     }
                 }
                 tfData.yearFirstTradingDate = yearFirstTradingDate;
                 tfData.monthFirstTradingDate = monthFirstTradingDate;
            }
            return payload;
        }

        // -----------------------------------------------------------
        // 4) Window-Helper
        // -----------------------------------------------------------
        function computeWindowForTf(tfData, visibleBars, centerIdx) {
            const bars = tfData.bars || [];
            if (!bars.length) {
                return {
                    windowStart: 0,
                    windowEnd: -1,
                    visibleStartIdx: 0,
                    visibleEndIdx: -1,
                    visibleBars: 0,
                    minIdx: 0,
                    maxIdx: -1,
                    viewStart: 0,
                    viewEnd: -1
                };
            }

            const minIdx = tfData.minIdx;
            const maxIdx = tfData.maxIdx;

            if (!visibleBars || visibleBars <= 0) visibleBars = DEFAULT_VISIBLE_BARS;
            if (centerIdx === null || centerIdx === undefined || !isFinite(centerIdx)) {
                centerIdx = maxIdx;
            }

            let halfVisible = Math.floor(visibleBars / 2);
            let visibleStartIdx = Math.round(centerIdx - halfVisible);
            let visibleEndIdx = visibleStartIdx + visibleBars - 1;

            if (visibleStartIdx < minIdx) {
                visibleStartIdx = minIdx;
                visibleEndIdx = visibleStartIdx + visibleBars - 1;
            }
            if (visibleEndIdx > maxIdx) {
                visibleEndIdx = maxIdx;
                visibleStartIdx = visibleEndIdx - visibleBars + 1;
                if (visibleStartIdx < minIdx) visibleStartIdx = minIdx;
            }

            visibleBars = Math.max(1, visibleEndIdx - visibleStartIdx + 1);

            let totalBars = Math.floor(visibleBars * BUFFER_FACTOR);
            if (totalBars < visibleBars) totalBars = visibleBars;

            const visibleCenter = 0.5 * (visibleStartIdx + visibleEndIdx);
            let halfTotal = Math.floor(totalBars / 2);
            let windowStart = Math.round(visibleCenter - halfTotal);
            let windowEnd = windowStart + totalBars - 1;

            if (windowStart < minIdx) {
                windowStart = minIdx;
                windowEnd = windowStart + totalBars - 1;
            }
            if (windowEnd > maxIdx) {
                windowEnd = maxIdx;
                windowStart = windowEnd - totalBars + 1;
                if (windowStart < minIdx) windowStart = minIdx;
            }

            // View-Range initial: perfekt auf sichtbare Daten gemappt
            const viewStart = visibleStartIdx - 0.5;
            const viewEnd   = visibleEndIdx + 0.5;

            return {
                windowStart,
                windowEnd,
                visibleStartIdx,
                visibleEndIdx,
                visibleBars,
                minIdx,
                maxIdx,
                viewStart,
                viewEnd
            };
        }

        function computeWindowForTfRightAnchored(tfData, visibleBars, anchorIdx) {
            const bars = tfData.bars || [];
            if (!bars.length) {
                return {
                    windowStart: 0,
                    windowEnd: -1,
                    visibleStartIdx: 0,
                    visibleEndIdx: -1,
                    visibleBars: 0,
                    minIdx: 0,
                    maxIdx: -1,
                    viewStart: 0,
                    viewEnd: -1
                };
            }

            const minIdx = tfData.minIdx;
            const maxIdx = tfData.maxIdx;

            if (!visibleBars || visibleBars <= 0) visibleBars = DEFAULT_VISIBLE_BARS;
            if (anchorIdx === null || anchorIdx === undefined || !isFinite(anchorIdx)) {
                return computeWindowForTf(tfData, visibleBars, null);
            }

            let visibleEndIdx = Math.round(anchorIdx);
            let visibleStartIdx = visibleEndIdx - (visibleBars - 1);

            if (visibleEndIdx > maxIdx) {
                visibleEndIdx = maxIdx;
                visibleStartIdx = visibleEndIdx - (visibleBars - 1);
            }
            if (visibleStartIdx < minIdx) {
                visibleStartIdx = minIdx;
                visibleEndIdx = visibleStartIdx + (visibleBars - 1);
                if (visibleEndIdx > maxIdx) visibleEndIdx = maxIdx;
            }

            visibleBars = Math.max(1, visibleEndIdx - visibleStartIdx + 1);

            let totalBars = Math.floor(visibleBars * BUFFER_FACTOR);
            if (totalBars < visibleBars) totalBars = visibleBars;

            const visibleCenter = 0.5 * (visibleStartIdx + visibleEndIdx);
            let halfTotal = Math.floor(totalBars / 2);
            let windowStart = Math.round(visibleCenter - halfTotal);
            let windowEnd = windowStart + totalBars - 1;

            if (windowStart < minIdx) {
                windowStart = minIdx;
                windowEnd = windowStart + totalBars - 1;
            }
            if (windowEnd > maxIdx) {
                windowEnd = maxIdx;
                windowStart = windowEnd - totalBars + 1;
                if (windowStart < minIdx) windowStart = minIdx;
            }

            const viewStart = visibleStartIdx - 0.5;
            const viewEnd   = visibleEndIdx + 0.5;

            return {
                windowStart,
                windowEnd,
                visibleStartIdx,
                visibleEndIdx,
                visibleBars,
                minIdx,
                maxIdx,
                viewStart,
                viewEnd
            };
        }

        function sliceBarsForRange(tfData, startIdx, endIdx) {
            const bars = tfData.bars;
            const minIdx = tfData.minIdx;
            if (endIdx < startIdx) return [];
            const startPos = Math.max(startIdx - minIdx, 0);
            const endPos = Math.min(endIdx - minIdx, bars.length - 1);
            if (endPos < startPos) return [];
            return bars.slice(startPos, endPos + 1);
        }

        function findPosGEByTs(tfData, targetTs) {
            const bars = tfData.bars;
            let lo = 0, hi = bars.length - 1, res = null;
            while (lo <= hi) {
                const mid = (lo + hi) >> 1;
                const ts = bars[mid].ts;
                if (ts >= targetTs) {
                    res = mid;
                    hi = mid - 1;
                } else {
                    lo = mid + 1;
                }
            }
            return res;
        }

        function findPosLEByTs(tfData, targetTs) {
            const bars = tfData.bars;
            let lo = 0, hi = bars.length - 1, res = null;
            while (lo <= hi) {
                const mid = (lo + hi) >> 1;
                const ts = bars[mid].ts;
                if (ts <= targetTs) {
                    res = mid;
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }
            return res;
        }

        // -----------------------------------------------------------
        // 4b) Intraday/Calendar-Raster + Labeling (UTC-basierter Port)
        // -----------------------------------------------------------

        function generateIntradayTicks(start, end, stepMin) {
            const ticks = [];
            if (!start || !end) return ticks;
            const stepMs = stepMin * 60 * 1000;

            // Basis: Vortag 00:00 (UTC) – wie im Python-Code, aber tz-naiv
            const base = new Date(Date.UTC(
                start.getUTCFullYear(),
                start.getUTCMonth(),
                start.getUTCDate()
            ));
            base.setUTCDate(base.getUTCDate() - 1);

            let t = base.getTime();
            const endExt = end.getTime() + stepMs;

            while (t <= endExt) {
                ticks.push(new Date(t));
                t += stepMs;
            }
            return ticks;
        }

        function generateCalendarTicks(start, end, intervalCode) {
            const ticks = [];
            if (!start || !end) return ticks;

            // Nur Datumsteil, 00:00 UTC (entspricht „naivem“ Datum)
            let s = new Date(Date.UTC(
                start.getUTCFullYear(),
                start.getUTCMonth(),
                start.getUTCDate()
            ));
            let e = new Date(Date.UTC(
                end.getUTCFullYear(),
                end.getUTCMonth(),
                end.getUTCDate()
            ));

            function addDays(d, n) {
                const nd = new Date(d.getTime());
                nd.setUTCDate(nd.getUTCDate() + n);
                return nd;
            }

            function addMonths(d, n) {
                const nd = new Date(d.getTime());
                nd.setUTCMonth(nd.getUTCMonth() + n);
                nd.setUTCDate(1);
                return nd;
            }

            let dt;

            if (intervalCode === "year") {
                let year = s.getUTCFullYear() - 1;
                dt = new Date(Date.UTC(year, 0, 1));
                const endExt = addMonths(e, 12);
                while (dt.getTime() <= endExt.getTime()) {
                    ticks.push(new Date(dt.getTime()));
                    dt = addMonths(dt, 12);
                }
            } else if (intervalCode === "quarter") {
                let year = s.getUTCFullYear();
                let month = s.getUTCMonth();
                let qMonth = 3 * Math.floor(month / 3) + 1;
                dt = new Date(Date.UTC(year, qMonth - 1, 1));
                dt = addMonths(dt, -3);
                const endExt = addMonths(e, 3);
                while (dt.getTime() <= endExt.getTime()) {
                    ticks.push(new Date(dt.getTime()));
                    dt = addMonths(dt, 3);
                }
            } else if (intervalCode === "month") {
                dt = new Date(Date.UTC(s.getUTCFullYear(), s.getUTCMonth(), 1));
                dt = addMonths(dt, -1);
                const endExt = addMonths(e, 1);
                while (dt.getTime() <= endExt.getTime()) {
                    ticks.push(new Date(dt.getTime()));
                    dt = addMonths(dt, 1);
                }
            } else if (intervalCode === "week_mon") {
                // Mo-only
                dt = new Date(s.getTime());
                const wd = dt.getUTCDay();             // 0=So,1=Mo,...
                const shift = (wd + 6) % 7;            // So->6, Mo->0, ...
                dt.setUTCDate(dt.getUTCDate() - shift);
                dt = addDays(dt, -7);
                const endExt = addDays(e, 7);
                while (dt.getTime() <= endExt.getTime()) {
                    if (dt.getUTCDay() === 1) {        // Montag
                        ticks.push(new Date(dt.getTime()));
                    }
                    dt = addDays(dt, 7);
                }
            } else if (intervalCode === "day_mwf") {
                // Mo-Mi-Fr
                dt = addDays(s, -1);
                const endExt = addDays(e, 1);
                while (dt.getTime() <= endExt.getTime()) {
                    const wd = dt.getUTCDay();
                    if (wd === 1 || wd === 3 || wd === 5) {
                        ticks.push(new Date(dt.getTime()));
                    }
                    dt = addDays(dt, 1);
                }
            } else if (intervalCode === "day_all") {
                // Alle Kalendertage inkl. Wochenende
                dt = addDays(s, -1);
                const endExt = addDays(e, 1);
                while (dt.getTime() <= endExt.getTime()) {
                    ticks.push(new Date(dt.getTime()));
                    dt = addDays(dt, 1);
                }
            } else {
                // "day" = alle Kalendertage (inkl. Sonntag)
                dt = addDays(s, -1);
                const endExt = addDays(e, 1);
                while (dt.getTime() <= endExt.getTime()) {
                    ticks.push(new Date(dt.getTime()));
                    dt = addDays(dt, 1);
                }
            }

            const uniqueSorted = Array.from(
                new Set(ticks.map(t => t.getTime()))
            ).sort((a, b) => a - b);

            const out = [];
            const minAllowed = addDays(s, -2).getTime();
            const maxAllowed = addDays(e, 2).getTime();
            for (const ms of uniqueSorted) {
                if (ms >= minAllowed && ms <= maxAllowed) {
                    out.push(new Date(ms));
                }
            }
            return out;
        }




        function formatTickLabels(ticks, intervalCode, anchorInfo, tickIndices, state, chartPixelWidth) {
            if (!ticks || !ticks.length) return { labels: [], hiddenTickvals: [] };

            anchorInfo = anchorInfo || {};
            const yearFirstTradingDate = anchorInfo.yearFirstTradingDate || {};
            const monthFirstTradingDate = anchorInfo.monthFirstTradingDate || {};

            const monthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

            function pad2(x) {
                return String(x).padStart(2, "0");
            }

            const levelOrder = { time: 0, day: 1, month: 2, year: 3 };

            let baseUnit;
            if (intervalCode === "year") {
                baseUnit = "year";
            } else if (intervalCode === "quarter" || intervalCode === "month") {
                baseUnit = "month";
            } else if (
                intervalCode === "week_mon" ||
                intervalCode === "day_mwf" ||
                intervalCode === "day" ||
                intervalCode === "day_all"
            ) {
                baseUnit = "day";
            } else {
                baseUnit = "time"; // Intraday
            }

            const isIntraday = baseUnit === "time";

            function highlight(text, unit) {
                if (levelOrder[unit] > levelOrder[baseUnit]) {
                    return "<span style='font-size:110%'><b>" + text + "</b></span>";
                }
                return text;
            }

            const units = [];   // "time" | "day" | "month" | "year"
            const texts = [];   // roher Text ohne HTML
            const labeledDates = new Set(); // nur Intraday: pro Datum max. ein höheres Label

            // ---------------- 1) Units + Raw-Text bestimmen ----------------
            for (const dt of ticks) {
                const y = dt.getUTCFullYear();
                const m = dt.getUTCMonth() + 1;
                const d = dt.getUTCDate();
                const wd = dt.getUTCDay(); // 0=So,...,6=Sa
                const hh = dt.getUTCHours();
                const mm = dt.getUTCMinutes();

                const yearStr   = String(y);                 // "2025"
                const monthName = monthNames[m - 1];         // "Jul"
                const monthStr  = monthName;
                const dayStr    = String(d);                 // "1", "2", ...
                const timeStr   = pad2(hh) + ":" + pad2(mm); // "00:00"

                let unit;
                let text;

                if (isIntraday) {
                    // -------- Intraday-Labeling (mit Trading-Ankern) --------
                    const dateKey = `${y}-${pad2(m)}-${pad2(d)}`;
                    const ymKey   = `${y}-${pad2(m)}`;

                    const anchorYearDate  = yearFirstTradingDate[y];
                    const anchorMonthDate = monthFirstTradingDate[ymKey];

                    const isMidnight = (hh === 0 && mm === 0);
                    const isDayOpen  = (hh === 17 && mm === 0); // Forex-Tag beginnt 17:00 NY
                    const isSunday   = (wd === 0);

                    unit = "time";
                    text = timeStr;

                    if (isMidnight) {
                        if (!isSunday && !labeledDates.has(dateKey)) {
                            if (anchorYearDate && dateKey === anchorYearDate) {
                                unit = "year";
                                text = yearStr;
                            } else if (anchorMonthDate && dateKey === anchorMonthDate) {
                                unit = "month";
                                text = monthStr;
                            } else {
                                unit = "day";
                                text = dayStr;
                            }
                            labeledDates.add(dateKey);
                        }
                    } else if (isDayOpen && isSunday) {
                        // Nur Sonntags darf 17:00 als "Tagesbeginn" dienen (Weekly Market Open).
                        if (!labeledDates.has(dateKey)) {
                            if (anchorYearDate && dateKey === anchorYearDate) {
                                unit = "year";
                                text = yearStr;
                            } else if (anchorMonthDate && dateKey === anchorMonthDate) {
                                unit = "month";
                                text = monthStr;
                            } else {
                                unit = "day";
                                text = dayStr;
                            }
                            labeledDates.add(dateKey);
                        }
                    }
                } else {
                    // ---------------- Non-Intraday (Kalender-Regime) ----------------
                    if (intervalCode === "year") {
                        unit = "year";
                        text = yearStr;

                    } else if (intervalCode === "quarter") {
                        // nur "Q1", "Q2", ... (auf Monatsebene)
                        const q = "Q" + (Math.floor((m - 1) / 3) + 1);
                        unit = "month";
                        text = q;

                    } else if (intervalCode === "month") {
                        unit = "month";
                        text = monthStr;

                    } else {
                        // day / day_mwf / week_mon / day_all
                        const month2 = pad2(m);
                        const dateKey = `${y}-${month2}-${pad2(d)}`;
                        const ymKey   = `${y}-${month2}`;

                        const anchorYearDate  = yearFirstTradingDate[y];
                        const anchorMonthDate = monthFirstTradingDate[ymKey];

                        if (anchorYearDate && dateKey === anchorYearDate) {
                            unit = "year";
                            text = yearStr;
                        } else if (anchorMonthDate && dateKey === anchorMonthDate) {
                            unit = "month";
                            text = monthName;
                        } else if (d === 1 && m === 1) {
                            unit = "year";
                            text = yearStr;
                        } else if (d === 1) {
                            unit = "month";
                            text = monthName;
                        } else {
                            unit = "day";
                            text = dayStr;
                        }
                    }
                }

                units.push(unit);
                texts.push(text);
            }

            // ---------------- 2) Pixelbasierte Safe-Zone um "dicke" Ticks ----------------
            const hiddenTickvals = [];

            const n = texts.length;
            if (n > 0 && tickIndices && tickIndices.length === n) {
                const SAFE_PIXEL_RADIUS = 40; // ~40px Safe-Zone

                let safeIndexRadius = 0.5; // Fallback

                try {
                    const width = chartPixelWidth;

                    let visSpan = null;
                    if (state && state.visibleStartIdx != null && state.visibleEndIdx != null) {
                        visSpan = Math.max(1, state.visibleEndIdx - state.visibleStartIdx);
                    } else {
                        // Fallback: Spanne über die Tick-Indizes selbst
                        let minIdx = tickIndices[0];
                        let maxIdx = tickIndices[0];
                        for (let i = 1; i < tickIndices.length; i++) {
                            if (tickIndices[i] < minIdx) minIdx = tickIndices[i];
                            if (tickIndices[i] > maxIdx) maxIdx = tickIndices[i];
                        }
                        visSpan = Math.max(1, maxIdx - minIdx);
                    }

                    if (width && visSpan) {
                        const pixelsPerIndex = width / visSpan;
                        safeIndexRadius = SAFE_PIXEL_RADIUS / pixelsPerIndex;
                    }
                } catch (e) {
                    // Fallback lassen
                }

                // Für jeden "dicken" Tick alle kleineren Ticks im Index-Radius muten
                for (let j = 0; j < n; j++) {
                    const uj = units[j];
                    if (!uj) continue;
                    const level_j = levelOrder[uj];
                    if (level_j === undefined) continue;

                    if (level_j > levelOrder[baseUnit]) {
                        const idxBig = tickIndices[j];

                        for (let i = 0; i < n; i++) {
                            if (i === j) continue;
                            if (!texts[i]) continue; // schon leer

                            const ui = units[i];
                            if (!ui) continue;
                            const level_i = levelOrder[ui];
                            if (level_i === undefined) continue;

                            // nur kleinere Labels wegnehmen
                            if (level_i < level_j) {
                                const idxSmall = tickIndices[i];
                                if (Math.abs(idxSmall - idxBig) <= safeIndexRadius) {
                                    texts[i] = "";
                                    hiddenTickvals.push(idxSmall);
                                }
                            }
                        }
                    }
                }
            }

            // ---------------- 3) Finale Labels mit Highlighting bauen ----------------
            const labels = [];
            for (let i = 0; i < texts.length; i++) {
                const text = texts[i];
                const unit = units[i];

                if (!text) {
                    labels.push("");
                } else {
                    labels.push(highlight(text, unit));
                }
            }

            return { labels, hiddenTickvals };
        }

        function computeTimeTicks(tfName, tfData, state, chartPixelWidth) {
            const barsAll = tfData.bars || [];
            if (!barsAll.length) {
                return { tickvals: [], ticktext: [] };
            }

            // ---------------- 1) Bars auf aktuelles WINDOW einschränken ----------------
            const ts_all = [];
            const idx_all = [];

            const wStart = (state && state.windowStart != null) ? state.windowStart : tfData.minIdx;
            const wEnd   = (state && state.windowEnd   != null) ? state.windowEnd   : tfData.maxIdx;

            for (const bar of barsAll) {
                if (bar.i < wStart || bar.i > wEnd) continue;
                const ts = bar.ts;
                if (!Number.isNaN(ts)) {
                    ts_all.push(ts);
                    idx_all.push(bar.i);
                }
            }

            // Fallback: falls aus irgendeinem Grund kein Bar im Window landet -> alles nehmen
            if (!ts_all.length) {
                for (const bar of barsAll) {
                    const ts = bar.ts;
                    if (!Number.isNaN(ts)) {
                        ts_all.push(ts);
                        idx_all.push(bar.i);
                    }
                }
            }

            if (!ts_all.length) {
                return { tickvals: [], ticktext: [] };
            }

            // Handels-Anker
            const anchorInfo = {
                yearFirstTradingDate: tfData.yearFirstTradingDate || {},
                monthFirstTradingDate: tfData.monthFirstTradingDate || {}
            };

            const visibleStartIdx = state.visibleStartIdx;
            const visibleEndIdx   = state.visibleEndIdx;

            // ---------------- 2) Sichtbare Zeiten bestimmen ----------------
            let visTimes = [];
            if (visibleStartIdx != null && visibleEndIdx != null) {
                for (let i = 0; i < idx_all.length; i++) {
                    const idx = idx_all[i];
                    if (idx >= visibleStartIdx && idx <= visibleEndIdx) {
                        visTimes.push(new Date(ts_all[i]));
                    }
                }
            }

            if (!visTimes.length) {
                visTimes = ts_all.map(ms => new Date(ms));
            }
            if (!visTimes.length) {
                return { tickvals: [], ticktext: [] };
            }

            const startTime = visTimes[0];
            const endTime   = visTimes[visTimes.length - 1];

            // ---------------- 3) Zeitskalen-Analyse ----------------
            const realSpanMinutes = Math.max(
                1,
                Math.round((endTime.getTime() - startTime.getTime()) / 60000.0)
            );

            const diffs = [];
            for (let i = 1; i < visTimes.length; i++) {
                const dtMin = (visTimes[i].getTime() - visTimes[i - 1].getTime()) / 60000.0;
                if (dtMin > 0) diffs.push(dtMin);
            }

            let medianStepMin;
            let logicalSpanMinutes;
            if (diffs.length) {
                const sorted = diffs.slice().sort((a, b) => a - b);
                const mid = Math.floor(sorted.length / 2);
                if (sorted.length % 2 === 0) {
                    medianStepMin = 0.5 * (sorted[mid - 1] + sorted[mid]);
                } else {
                    medianStepMin = sorted[mid];
                }
                logicalSpanMinutes = medianStepMin * (visTimes.length - 1);
            } else {
                medianStepMin = realSpanMinutes;
                logicalSpanMinutes = realSpanMinutes;
            }

            const dayMinutes   = 24 * 60;
            const logicalDays  = logicalSpanMinutes / dayMinutes;

            let data_is_intraday = medianStepMin < 20 * 60;
            let data_is_daily_base =
                !data_is_intraday &&
                medianStepMin >= 0.5 * dayMinutes &&
                medianStepMin <= 1.5 * dayMinutes;

            // H4: niemals Intraday-Raster, immer Calendar (egal ob links oder rechts)
            const isH4 = (tfName === "H4");
            if (isH4) {
                data_is_intraday = false;
                data_is_daily_base = true;
            }

            // Intraday -> bei sehr weitem Span lieber Calendar
            const preferCalendarForIntraday =
                data_is_intraday && logicalDays >= 20;

            // ---------------- 4) Globales max_ticks (abhängig von Chartbreite + Datenanteil) ----------------
            let max_ticks = 32; // Fallback

            if (chartPixelWidth && chartPixelWidth > 0) {
                let effWidth = chartPixelWidth;

                // Wenn View größer als Datenanteil ist, skaliere die effektive Breite
                if (state &&
                    state.viewStart != null &&
                    state.viewEnd != null &&
                    state.visibleStartIdx != null &&
                    state.visibleEndIdx != null) {

                    const vLeft  = Math.min(state.viewStart, state.viewEnd);
                    const vRight = Math.max(state.viewStart, state.viewEnd);
                    const viewSpan = vRight - vLeft;

                    const dataSpan = Math.max(0, state.visibleEndIdx - state.visibleStartIdx);

                    if (viewSpan > 0 && dataSpan >= 0) {
                        let frac = dataSpan / viewSpan;  // Anteil der Achse mit echten Daten (0..1)
                        if (!isFinite(frac) || frac < 0) frac = 0;

                        // Mindestens 5% Breite, max. 100%, damit nie ganz auf 0 geht
                        const clamped = Math.max(0.05, Math.min(1, frac));
                        effWidth = chartPixelWidth * clamped;
                    }
                }

                // Pro ~72px ein Tick
                max_ticks = Math.max(2, Math.floor(effWidth / 72));
            }

            // ---------------- 5) Hilfsfunktionen ----------------
            function searchsortedLeft(arr, value) {
                let lo = 0;
                let hi = arr.length;
                while (lo < hi) {
                    const mid = (lo + hi) >> 1;
                    if (arr[mid] < value) {
                        lo = mid + 1;
                    } else {
                        hi = mid;
                    }
                }
                return lo;
            }

            // Projiziert Kandidaten-Ticks auf Bars (MAPPING + WEEKEND-FIX)
            function projectTicks(candTicks, useMappedDatetime) {
                const vals = [];
                const dts  = [];

                for (const dt of candTicks) {
                    const ts = dt.getTime();
                    const pos = searchsortedLeft(ts_all, ts);
                    if (pos >= ts_all.length) continue;

                    const mappedTs = new Date(ts_all[pos]);
                    const barIdx   = idx_all[pos];

                    // Nur Ticks im/nahe Sichtbereich
                    if (visibleStartIdx != null && barIdx < (visibleStartIdx - 1)) continue;
                    if (visibleEndIdx   != null && barIdx > (visibleEndIdx   + 1)) continue;

                    // Mehrere Rasterpunkte (z.B. Wochenende) auf derselben Bar -> nur einmal
                    if (vals.length && barIdx === vals[vals.length - 1]) continue;

                    vals.push(barIdx);
                    dts.push(useMappedDatetime ? mappedTs : dt);
                }

                return { vals, dts };
            }

            function pickBestIntraday(start, end) {
                const intradaySteps = [
                    ["15min",  15],
                    ["30min",  30],
                    ["1h",     60],
                    ["2h",    120],
                    ["4h",    240],
                    ["8h",    480],
                    ["12h",   720],
                ];

                let best = null;        // bester Kandidat mit nVis <= max_ticks
                let fallback = null;    // gröbster Kandidat (letzter mit nVis > 0)

                for (const [code, step] of intradaySteps) {
                    const candTicks = generateIntradayTicks(start, end, step);
                    if (!candTicks.length) continue;

                    const proj = projectTicks(candTicks, false);
                    const nVis = proj.vals.length;
                    if (!nVis) continue;

                    fallback = { code, candTicks, nVis };

                    if (nVis <= max_ticks) {
                        if (!best || nVis > best.nVis) {
                            best = { code, candTicks, nVis };
                        }
                    }
                }

                if (best) return best;
                if (fallback) return fallback;
                return null;
            }

            function pickBestCalendar(start, end) {
                const calendarCandidates = data_is_daily_base
                    ? ["day_all", "day_mwf", "week_mon", "month", "quarter", "year"]
                    : ["day",     "day_mwf", "week_mon", "month", "quarter", "year"];

                let best = null;
                let fallback = null;

                for (const code of calendarCandidates) {
                    const candTicks = generateCalendarTicks(start, end, code);
                    if (!candTicks.length) continue;

                    const proj = projectTicks(candTicks, false);
                    const nVis = proj.vals.length;
                    if (!nVis) continue;

                    fallback = { code, candTicks, nVis };

                    if (nVis <= max_ticks) {
                        if (!best || nVis > best.nVis) {
                            best = { code, candTicks, nVis };
                        }
                    }
                }

                if (best) return best;
                if (fallback) return fallback;
                return null;
            }

            // ---------------- 6) Intraday vs Calendar auswählen ----------------
            let useIntradayGrid = false;
            let intervalCode = null;
            let tickDtList = null;

            // NEU: Intraday nur nehmen, wenn der Kandidat wirklich <= max_ticks ist.
            let intradayChoice = null;
            if (data_is_intraday && !preferCalendarForIntraday) {
                const candidate = pickBestIntraday(startTime, endTime);
                if (candidate && candidate.nVis <= max_ticks) {
                    intradayChoice = candidate;
                }
            }

            if (intradayChoice) {
                useIntradayGrid = true;
                intervalCode = intradayChoice.code;
                tickDtList   = intradayChoice.candTicks;
            }

            // Falls kein brauchbares Intraday-Raster: immer Calendar-Regime
            if (!tickDtList || !tickDtList.length) {
                const bestCal = pickBestCalendar(startTime, endTime);
                if (bestCal) {
                    intervalCode = bestCal.code;
                    tickDtList   = bestCal.candTicks;
                }
            }

            if (!tickDtList || !tickDtList.length) {
                return { tickvals: [], ticktext: [] };
            }

            // ---------------- 7) Finale Projektion auf Bars mit optionalem Mapped-Datetime ----------------
            const useMappedDatetime = data_is_intraday && useIntradayGrid;
            let projected = projectTicks(tickDtList, useMappedDatetime);
            let tickvals = projected.vals;
            let tickDatetimes = projected.dts;

            if (!tickvals.length) {
                return { tickvals: [], ticktext: [] };
            }

            // ---------------- 8) Monats-Erster-Handelstag für Tagesraster ----------------
            if (
                intervalCode === "day" ||
                intervalCode === "day_all" ||
                intervalCode === "day_mwf" ||
                intervalCode === "week_mon"
            ) {
                const mft = tfData.monthFirstTradingDate || {};
                const extra = [];

                const visStartCheck = (visibleStartIdx != null) ? visibleStartIdx - 1 : null;
                const visEndCheck   = (visibleEndIdx   != null) ? visibleEndIdx   + 1 : null;

                for (const [ymKey, dateStr] of Object.entries(mft)) {
                    const parts = dateStr.split("-");
                    if (parts.length !== 3) continue;
                    const yy = Number(parts[0]);
                    const mm = Number(parts[1]);
                    const dd = Number(parts[2]);
                    if (!yy || !mm || !dd) continue;

                    const anchorDt = new Date(Date.UTC(yy, mm - 1, dd));
                    const anchorMs = anchorDt.getTime();

                    if (anchorMs < startTime.getTime() - 2 * 86400000 ||
                        anchorMs > endTime.getTime()   + 2 * 86400000) {
                        continue;
                    }

                    const pos = searchsortedLeft(ts_all, anchorMs);
                    if (pos >= ts_all.length) continue;

                    const barIdx = idx_all[pos];

                    if (visStartCheck != null && barIdx < visStartCheck) continue;
                    if (visEndCheck   != null && barIdx > visEndCheck)   continue;

                    if (tickvals.includes(barIdx)) continue;

                    let duplicateDate = false;
                    for (const dtExisting of tickDatetimes) {
                        if (
                            dtExisting.getUTCFullYear() === yy &&
                            dtExisting.getUTCMonth() === (mm - 1) &&
                            dtExisting.getUTCDate() === dd
                        ) {
                            duplicateDate = true;
                            break;
                        }
                    }
                    if (duplicateDate) continue;

                    extra.push({ idx: barIdx, dt: anchorDt });
                }

                if (extra.length) {
                    const combined = [];
                    for (let i = 0; i < tickvals.length; i++) {
                        combined.push({ idx: tickvals[i], dt: tickDatetimes[i] });
                    }
                    for (const e of extra) {
                        combined.push(e);
                    }
                    combined.sort((a, b) => a.idx - b.idx);

                    const newVals = [];
                    const newDts = [];
                    for (const item of combined) {
                        if (newVals.length && item.idx === newVals[newVals.length - 1]) continue;
                        newVals.push(item.idx);
                        newDts.push(item.dt);
                    }
                    tickvals = newVals;
                    tickDatetimes = newDts;
                }
            }

            // ---------------- 9) Labels + Safe-Zone + hiddenTickvals ----------------
            const labelInfo = formatTickLabels(
                tickDatetimes,
                intervalCode,
                anchorInfo,
                tickvals,
                state,
                chartPixelWidth
            );

            const tickvalsFinal = tickvals;
            const ticktextFinal = labelInfo.labels;

            console.log(
                "[ticks]",
                tfName,
                "paneWidth=", chartPixelWidth,
                "max_ticks=", max_ticks,
                "mode=", intervalCode,
                "nTicks=", tickvalsFinal.length
            );

            return {
                tickvals: tickvalsFinal,
                ticktext: ticktextFinal,
                hiddenTickvals: labelInfo.hiddenTickvals || []
            };
        }

        // -----------------------------------------------------------
        // 4c) Session-Polygone (Asia / Frankfurt / London / New York)
        // -----------------------------------------------------------

        function buildSessionTraces(tf, tfData, state, windowBars, visibleBarsArr) {
            const traces = [];
            if (!windowBars || !windowBars.length) return traces;
            if (!visibleBarsArr || !visibleBarsArr.length) return traces;
            if (!sessionDays || sessionDays <= 0) return traces;

            // Keine Sessions auf H4 und größeren TFs
            if (tf === "H4" || tf === "D" || tf === "W" || tf === "M") return traces;

            // Nur Intraday-/Hourly-Regime einfärben
            const regime = getRegime(tf);
            if (regime === "daily") return traces;

            const visibleStartIdx = state.visibleStartIdx;
            const visibleEndIdx = state.visibleEndIdx;
            if (visibleStartIdx == null || visibleEndIdx == null) return traces;

            // --- 1) NY-Trading-Tage im gesamten Window bestimmen (17:00–17:00) ---
            //     + pro Tag den ersten/letzten Index merken
            const dayInfo = {}; // dayKey -> { firstIdx, lastIdx }

            for (const bar of windowBars) {
                const dt = new Date(bar.ts);
                const key = tradingDateKeyFromDate(dt);
                if (!dayInfo[key]) {
                    dayInfo[key] = { firstIdx: bar.i, lastIdx: bar.i };
                } else {
                    if (bar.i < dayInfo[key].firstIdx) dayInfo[key].firstIdx = bar.i;
                    if (bar.i > dayInfo[key].lastIdx)  dayInfo[key].lastIdx = bar.i;
                }
            }

            let allWindowDays = Object.keys(dayInfo);
            if (!allWindowDays.length) return traces;
            allWindowDays.sort(); // chrono von links nach rechts

            // --- 2) Tage finden, die im sichtbaren Bereich liegen ---
            const visibleDays = [];       // alle Tage, die den sichtbaren Bereich schneiden
            const fullVisibleDays = [];   // komplett im sichtbaren Bereich
            let leftPartialDay = null;    // links angeschnitten
            let rightPartialDay = null;   // rechts angeschnitten

            for (const dayKey of allWindowDays) {
                const info = dayInfo[dayKey];
                const firstIdx = info.firstIdx;
                const lastIdx  = info.lastIdx;

                const intersects =
                    (lastIdx >= visibleStartIdx) &&
                    (firstIdx <= visibleEndIdx);

                if (!intersects) continue;

                visibleDays.push(dayKey);

                const isFull =
                    (firstIdx >= visibleStartIdx) &&
                    (lastIdx  <= visibleEndIdx);

                if (isFull) {
                    fullVisibleDays.push(dayKey);
                } else {
                    const touchesLeft =
                        (firstIdx < visibleStartIdx) &&
                        (lastIdx  >= visibleStartIdx);
                    const touchesRight =
                        (lastIdx > visibleEndIdx) &&
                        (firstIdx <= visibleEndIdx);

                    if (touchesLeft) {
                        leftPartialDay = dayKey;
                    }
                    if (touchesRight) {
                        rightPartialDay = dayKey;
                    }
                }
            }

            // maxDays: mindestens 3, höchstens 60
            const rawMax = (typeof sessionDays === "number" ? sessionDays : DEFAULT_SESSION_DAYS);
            const maxDays = Math.max(3, Math.min(rawMax, 60));

            let selectedDayKeys = [];

            // --- 3) Fallback, falls keine sichtbaren Tage gefunden (extremer Spezialfall) ---
            if (!visibleDays.length) {
                if (allWindowDays.length <= maxDays) {
                    selectedDayKeys = allWindowDays.slice();
                } else {
                    // wie früher: rechtsbündig
                    selectedDayKeys = allWindowDays.slice(allWindowDays.length - maxDays);
                }
            } else if (visibleDays.length >= maxDays) {
                // --- 4) Sichtbarer Bereich enthält mehr Tage als das Kontingent ---
                // Priorität: fullVisibleDays, dann rightPartialDay, dann leftPartialDay
                let selected = fullVisibleDays.slice(); // chronologisch

                if (rightPartialDay && !selected.includes(rightPartialDay)) {
                    selected.push(rightPartialDay);
                }
                if (leftPartialDay && !selected.includes(leftPartialDay)) {
                    selected.push(leftPartialDay);
                }

                // Wenn zu viele -> entferne von links, aber rechte Kante (rightPartialDay) schützen
                while (selected.length > maxDays) {
                    let removed = false;
                    for (let i = 0; i < selected.length; i++) {
                        const dk = selected[i];
                        if (rightPartialDay && dk === rightPartialDay) {
                            continue; // nicht entfernen
                        }
                        selected.splice(i, 1);
                        removed = true;
                        break;
                    }
                    if (!removed) break; // sollte praktisch nie passieren
                }

                selectedDayKeys = selected.slice();
            } else {
                // --- 5) Alle sichtbaren Tage passen ins Kontingent ---
                // -> zuerst alle sichtbaren Tage, dann Rest gleichmäßig links/rechts
                selectedDayKeys = visibleDays.slice();
                const selectedSet = new Set(selectedDayKeys);

                let remaining = maxDays - selectedDayKeys.length;

                if (remaining > 0 && allWindowDays.length > selectedDayKeys.length) {
                    const firstVisible = visibleDays[0];
                    const lastVisible  = visibleDays[visibleDays.length - 1];

                    const idxFirstVis = allWindowDays.indexOf(firstVisible);
                    const idxLastVis  = allWindowDays.indexOf(lastVisible);

                    let leftIdx  = idxFirstVis - 1;
                    let rightIdx = idxLastVis + 1;

                    while (remaining > 0 && (leftIdx >= 0 || rightIdx < allWindowDays.length)) {
                        if (remaining === 1) {
                            // letzte Einheit -> rechts priorisieren
                            if (rightIdx < allWindowDays.length) {
                                const dk = allWindowDays[rightIdx];
                                if (!selectedSet.has(dk)) {
                                    selectedDayKeys.push(dk);
                                    selectedSet.add(dk);
                                    remaining--;
                                }
                                rightIdx++;
                            } else if (leftIdx >= 0) {
                                const dk = allWindowDays[leftIdx];
                                if (!selectedSet.has(dk)) {
                                    selectedDayKeys.unshift(dk);
                                    selectedSet.add(dk);
                                    remaining--;
                                }
                                leftIdx--;
                            } else {
                                break;
                            }
                        } else {
                            // mindestens 2 übrig -> möglichst symmetrisch links/rechts
                            let addedSomething = false;

                            if (leftIdx >= 0) {
                                const dkL = allWindowDays[leftIdx];
                                if (!selectedSet.has(dkL)) {
                                    selectedDayKeys.unshift(dkL);
                                    selectedSet.add(dkL);
                                    remaining--;
                                    addedSomething = true;
                                }
                                leftIdx--;
                            }

                            if (remaining > 0 && rightIdx < allWindowDays.length) {
                                const dkR = allWindowDays[rightIdx];
                                if (!selectedSet.has(dkR)) {
                                    selectedDayKeys.push(dkR);
                                    selectedSet.add(dkR);
                                    remaining--;
                                    addedSomething = true;
                                }
                                rightIdx++;
                            }

                            if (!addedSomething) {
                                break;
                            }
                        }
                    }
                }
            }

            if (!selectedDayKeys.length) return traces;

            // sicherstellen, dass chronologische Reihenfolge eingehalten wird
            selectedDayKeys = selectedDayKeys
                .filter((dk) => dayInfo[dk])
                .sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));

            // --- 6) Für jeden ausgewählten Trading-Day & jede Session ein High/Low-Polygon bauen ---
            for (const dayKey of selectedDayKeys) {
                const baseDate = dateFromKey(dayKey); // 00:00 des NY-Handelstags
                if (!baseDate) continue;

                for (const s of SESSION_CONFIG) {
                    const startBase = addDaysUtc(baseDate, s.startOffsetDays || 0);
                    const endBase   = addDaysUtc(baseDate, s.endOffsetDays   || 0);

                    const sy = startBase.getUTCFullYear();
                    const sm = startBase.getUTCMonth();
                    const sd = startBase.getUTCDate();

                    const ey = endBase.getUTCFullYear();
                    const em = endBase.getUTCMonth();
                    const ed = endBase.getUTCDate();

                    const startMs = Date.UTC(sy, sm, sd, s.startHour, s.startMinute, 0);
                    const endMs   = Date.UTC(ey, em, ed, s.endHour,   s.endMinute,   0);

                    const barsInSession = [];
                    for (const bar of windowBars) {
                        if (bar.ts >= startMs && bar.ts < endMs) {
                            barsInSession.push(bar);
                        }
                    }
                    if (!barsInSession.length) continue;

                    let runningHigh = barsInSession[0].h;
                    let runningLow  = barsInSession[0].l;

                    const xTop = [];
                    const yTop = [];
                    const xBottom = [];
                    const yBottom = [];

                    for (const bar of barsInSession) {
                        if (bar.h > runningHigh) runningHigh = bar.h;
                        if (bar.l < runningLow)  runningLow  = bar.l;

                        // Oberkante: laufendes High
                        xTop.push(bar.i);
                        yTop.push(runningHigh);

                        // Unterkante: laufendes Low
                        xBottom.push(bar.i);
                        yBottom.push(runningLow);
                    }

                    // zusätzliche Kerze nach rechts, damit Polygon optisch bis zur Sessions-Grenze läuft
                    const lastBarInSession = barsInSession[barsInSession.length - 1];
                    if (lastBarInSession) {
                        const maxWindowIdx = windowBars[windowBars.length - 1].i;
                        let extendIdx = lastBarInSession.i + 1;
                        if (extendIdx > maxWindowIdx) {
                            extendIdx = maxWindowIdx;
                        }
                        if (extendIdx > lastBarInSession.i) {
                            xTop.push(extendIdx);
                            yTop.push(runningHigh);
                            xBottom.push(extendIdx);
                            yBottom.push(runningLow);
                        }
                    }

                    const xPoly = xTop.concat(xBottom.slice().reverse());
                    const yPoly = yTop.concat(yBottom.slice().reverse());

                    traces.push({
                        type: "scatter",
                        x: xPoly,
                        y: yPoly,
                        mode: "lines",
                        line: { width: 0 },
                        fill: "toself",
                        fillcolor: s.fillColor,
                        hoverinfo: "skip",
                        name: s.name,
                        legendgroup: "sessions",
                        showlegend: false
                    });
                }
            }

            return traces;
        }

        // Referenz-Timeframe für die Y-Grenzen der Phase2-Boxen
        // Idee: zuerst den aus dem Phase2-Dateinamen abgeleiteten TF nutzen,
        // dann M5/M1/..., dann irgendeinen TF als Fallback.
        function getPhase2BaseTfData() {
            if (!DATA || !DATA.timeframes) return null;

            // Wenn schon bestimmt und noch vorhanden → wiederverwenden
            if (PHASE2_BASE_TF && DATA.timeframes[PHASE2_BASE_TF]) {
                return DATA.timeframes[PHASE2_BASE_TF];
            }

            const tried = new Set();
            const order = [];

            // 1) TF aus Phase2-Datei (z.B. M5 aus _M5_phase2_setups.csv)
            if (PHASE2_SIGNAL_BASE_TF) {
                order.push(PHASE2_SIGNAL_BASE_TF);
            }

            // 2) Fallback-Prio: M5, M1, M3, M15, H1
            order.push("M5", "M1", "M3", "M15", "H1");

            for (const tf of order) {
                if (tried.has(tf)) continue;
                tried.add(tf);
                const tfData = DATA.timeframes[tf];
                if (tfData && tfData.bars && tfData.bars.length) {
                    PHASE2_BASE_TF = tf;
                    return tfData;
                }
            }

            // 3) Letzter Fallback: irgendein vorhandener TF
            const keys = Object.keys(DATA.timeframes);
            for (const tf of keys) {
                if (tried.has(tf)) continue;
                const tfData = DATA.timeframes[tf];
                if (tfData && tfData.bars && tfData.bars.length) {
                    PHASE2_BASE_TF = tf;
                    return tfData;
                }
            }
            return null;
        }

        // -----------------------------------------------------------
        // 4d) Phase2-Boxen (Long = blau, Short = rot)
        // -----------------------------------------------------------

function buildPhase2Traces(tf, tfData, windowBars, windowStartIdx, windowEndIdx, pane) {
            const traces = [];
            if (!PHASE2_BOXES || !PHASE2_BOXES.length) return traces;

            // Signals global ausblendbar
            if (!SHOW_SIGNALS) return traces;

            const minIdx = windowStartIdx;
            const maxIdx = windowEndIdx;

            // Referenz-TF für Y-Grenzen (z.B. M5)
            const baseTfData = getPhase2BaseTfData();

            // Globales Zeit-Limit für Boxen im linken (HTF) Pane
            let maxBoxCloseTs = null;
            if (pane === "left") {
                // Setup-Snapshot hat Vorrang
                if (HTF_SNAPSHOT_MAX_SIGNAL_TS != null && isFinite(HTF_SNAPSHOT_MAX_SIGNAL_TS)) {
                    maxBoxCloseTs = HTF_SNAPSHOT_MAX_SIGNAL_TS;
                }
                // sonst: Follow-Snapshot (HTF follows LTF)
                else if (
                    HTF_FOLLOW_ACTIVE &&
                    HTF_FOLLOW_INFO &&
                    HTF_FOLLOW_INFO.snapshotTime != null &&
                    isFinite(HTF_FOLLOW_INFO.snapshotTime)
                ) {
                    maxBoxCloseTs = HTF_FOLLOW_INFO.snapshotTime;
                }
            }

            for (const box of PHASE2_BOXES) {
                const t1 = box.topTs;
                const t2 = box.bottomTs;
                if (!Number.isFinite(t1) || !Number.isFinite(t2)) continue;

                const startTs = Math.min(t1, t2);
                
                // --- Berechnung der Rechtskante (Zeit) ---
                let searchRightTs = null;
                let logicalCloseTs = null; // Nur für den Filter im HTF Chart

                if (box.signalTs != null && Number.isFinite(box.signalTs)) {
                    // 1. Wir berechnen den ECHTEN Close-Zeitpunkt (z.B. 09:35 M5 Start + 5min = 09:40 Close)
                    logicalCloseTs = box.signalTs + (PHASE2_SIGNAL_BASE_MINUTES || 5) * 60 * 1000;
                    
                    // 2. Wir suchen die Kerze, die VOR diesem Close-Zeitpunkt liegt.
                    //    Dazu ziehen wir 1ms ab (09:39:59.999).
                    //    -> M1 (09:39 Open, 09:40 Close): 09:39 <= 09:39.999 -> TREFFER.
                    //    -> M3 (09:39 Open, 09:42 Close): 09:39 <= 09:39.999 -> TREFFER.
                    searchRightTs = logicalCloseTs - 1;

                } else {
                    // Fallback: Wir haben keine Signalzeit, nur Box-Grenzen (Open Times).
                    // Hier ziehen wir NICHTS ab, da wir die Kerze AUF dieser Zeit treffen wollen.
                    logicalCloseTs = Math.max(t1, t2);
                    searchRightTs = logicalCloseTs;
                }

                // Zeitfilter im linken HTF-Chart (Zukunfts-Boxen ausblenden)
                // Hier nutzen wir die logische Close-Zeit (z.B. 09:40)
                if (pane === "left" && maxBoxCloseTs != null && logicalCloseTs != null && logicalCloseTs > maxBoxCloseTs) {
                    continue;
                }

                // --- X-Bereich im AKTUELLEN TF bestimmen ---
                
                // Links: Candle, deren Open <= startTs (Standard)
                let posL = findPosLEByTs(tfData, startTs);
                
                // Rechts: Candle, deren Open <= searchRightTs
                // Durch den Abzug von 1ms oben landen wir bei "Open-Time-Logik" exakt auf der Kerze,
                // die VOR der Close-Zeit geöffnet hat.
                let posR = findPosLEByTs(tfData, searchRightTs);

                // Fallbacks, falls außerhalb des Datenbereichs
                if (posL === null) posL = 0;
                if (posR === null) posR = tfData.bars.length - 1;
                if (posR < posL) {
                    const tmp = posL;
                    posL = posR;
                    posR = tmp;
                }

                const idxL = tfData.bars[posL].i;
                const idxR = tfData.bars[posR].i;

                // Mit aktuellem Window schneiden
                let leftIdx  = Math.max(minIdx, Math.min(idxL, idxR));
                let rightIdx = Math.min(maxIdx, Math.max(idxL, idxR));
                if (rightIdx < minIdx || leftIdx > maxIdx || rightIdx < leftIdx) continue;

                // --- Y-Bereich: EINMAL global im Base-TF berechnen & cachen ---
                let hiBox = box.priceHi;
                let loBox = box.priceLo;

                if (!Number.isFinite(hiBox) || !Number.isFinite(loBox)) {
                    if (baseTfData && baseTfData.bars && baseTfData.bars.length) {
                        let posBaseL = findPosLEByTs(baseTfData, startTs);
                        let posBaseR = findPosLEByTs(baseTfData, searchRightTs);

                        if (posBaseL === null) posBaseL = 0;
                        if (posBaseR === null) posBaseR = baseTfData.bars.length - 1;
                        if (posBaseR < posBaseL) {
                            const tmp = posBaseL;
                            posBaseL = posBaseR;
                            posBaseR = tmp;
                        }

                        const idxBaseL = baseTfData.bars[posBaseL].i;
                        const idxBaseR = baseTfData.bars[posBaseR].i;

                        const baseBarsInBox = sliceBarsForRange(baseTfData, idxBaseL, idxBaseR);
                        if (baseBarsInBox.length) {
                            let hi = Number.NEGATIVE_INFINITY;
                            let lo = Number.POSITIVE_INFINITY;

                            for (const b of baseBarsInBox) {
                                if (b.h > hi) hi = b.h;
                                if (b.l < lo) lo = b.l;
                            }

                            if (Number.isFinite(hi) && Number.isFinite(lo)) {
                                hiBox = hi;
                                loBox = lo;
                                box.priceHi = hi;
                                box.priceLo = lo;
                            }
                        }
                    }

                    // Fallback: falls Base-TF nicht greift, Y aus aktuellem TF
                    if (!Number.isFinite(hiBox) || !Number.isFinite(loBox)) {
                        const barsInBox = sliceBarsForRange(tfData, leftIdx, rightIdx);
                        if (!barsInBox.length) continue;

                        let hi = Number.NEGATIVE_INFINITY;
                        let lo = Number.POSITIVE_INFINITY;
                        for (const bar of barsInBox) {
                            if (bar.h > hi) hi = bar.h;
                            if (bar.l < lo) lo = bar.l;
                        }
                        if (!Number.isFinite(hi) || !Number.isFinite(lo)) continue;

                        hiBox = hi;
                        loBox = lo;
                        box.priceHi = hi;
                        box.priceLo = lo;
                    }
                }

                // --- Box-Geometrie: Candlegap-Mitte bis Candlegap-Mitte ---
                const x0 = leftIdx  - CANDLE_BODY_HALF_WIDTH;
                const x1 = rightIdx + CANDLE_BODY_HALF_WIDTH;

                const xPoly = [x0, x1, x1, x0, x0];
                const yPoly = [hiBox, hiBox, loBox, loBox, hiBox];

                const isBuy = box.direction === "buy";
                const borderColor = isBuy ? "rgba(0,0,255,0.9)" : "rgba(255,0,0,0.9)";

                const isSnapshotBox = (pane === "left" && box.isSnapshotActive === true);
                const snapshotBoxWidth = 1;
                const regularBoxWidth = 1;

                traces.push({
                    type: "scatter",
                    x: xPoly,
                    y: yPoly,
                    mode: "lines",
                    line: {
                        width: isSnapshotBox ? snapshotBoxWidth : regularBoxWidth,
                        color: borderColor,
                        dash: isSnapshotBox ? "solid" : "dot"
                    },
                    fill: "none",
                    hoverinfo: "skip",
                    name: isBuy ? "Phase2 BUY" : "Phase2 SELL",
                    legendgroup: "phase2",
                    showlegend: false
                });
            }

            return traces;
        }

        // -----------------------------------------------------------
        // 4e) Phase3-Trades (Positionsbox + Entry->Exit-Linie)
        // -----------------------------------------------------------

        function buildPhase3Traces(tf, tfData, windowBars, windowStartIdx, windowEndIdx, pane) {
            const traces = [];
            if (!PHASE3_TRADES || !PHASE3_TRADES.length) return traces;

            const minIdx = windowStartIdx;
            const maxIdx = windowEndIdx;

            // ---------------------------------------------------
            // Zeit-Filter für HTF-Snapshot (Zukunft ausblenden)
            // ---------------------------------------------------
            let maxAllowedTs = null;
            if (pane === "left") {
                if (HTF_SNAPSHOT_MAX_SIGNAL_TS != null && isFinite(HTF_SNAPSHOT_MAX_SIGNAL_TS)) {
                    maxAllowedTs = HTF_SNAPSHOT_MAX_SIGNAL_TS;
                } else if (
                    HTF_FOLLOW_ACTIVE &&
                    HTF_FOLLOW_INFO &&
                    HTF_FOLLOW_INFO.snapshotTime != null &&
                    isFinite(HTF_FOLLOW_INFO.snapshotTime)
                ) {
                    maxAllowedTs = HTF_FOLLOW_INFO.snapshotTime;
                }
            }

            for (const tr of PHASE3_TRADES) {
                // Check ob Trade in der Zukunft liegt (relativ zum Snapshot)
                if (pane === "left" && maxAllowedTs != null) {
                    let checkTs = null;
                    if (tr.entryTs != null && Number.isFinite(tr.entryTs)) {
                        checkTs = tr.entryTs;
                    } else if (tr.entryWindowEndTs != null && Number.isFinite(tr.entryWindowEndTs)) {
                        checkTs = tr.entryWindowEndTs;
                    }
                    if (checkTs != null && checkTs > maxAllowedTs) {
                        continue;
                    }
                }

                const isBuy = tr.direction === "buy";
                const hasEntryTs = tr.entryTs != null && Number.isFinite(tr.entryTs);
                const hasExitTs = tr.exitTs != null && Number.isFinite(tr.exitTs);
                const isFilled = tr.filled && hasEntryTs && hasExitTs;
                const isMissed = !tr.filled;

                if (!SHOW_MISSES && isMissed) {
                    continue;
                }

                // ---------------------------------------------------
                // FALL A: gefillter Trade -> SL/TP/PnL + Diagonale
                // ---------------------------------------------------
                if (isFilled) {
                    const entryTs = tr.entryTs;
                    const exitTs  = tr.exitTs;

                    let posEntry = findPosGEByTs(tfData, entryTs);
                    let posExit  = findPosGEByTs(tfData, exitTs);

                    if (posEntry === null) posEntry = findPosLEByTs(tfData, entryTs);
                    if (posExit === null) posExit = findPosLEByTs(tfData, exitTs);

                    if (posEntry === null || posExit === null) continue;

                    const idxEntry = tfData.bars[posEntry].i;
                    const idxExit  = tfData.bars[posExit].i;

                    // Sichtbarkeits-Check
                    const minTradeIdx = Math.min(idxEntry, idxExit);
                    const maxTradeIdx = Math.max(idxEntry, idxExit);
                    if (maxTradeIdx < minIdx || minTradeIdx > maxIdx) continue;

                    let entryPrice = tr.entryPrice;
                    if (!Number.isFinite(entryPrice)) entryPrice = tfData.bars[posEntry].c;

                    let exitPrice = tr.exitPrice;
                    if (!Number.isFinite(exitPrice)) exitPrice = tfData.bars[posExit].c;

                    const slPrice = Number.isFinite(tr.slPrice) ? tr.slPrice : NaN;
                    const tpPrice = Number.isFinite(tr.tpPrice) ? tr.tpPrice : NaN;

                    // -----------------------------------------------------------
                    // ÄNDERUNG: Offset-Logik für Single-Candle vs Multi-Candle
                    // -----------------------------------------------------------
                    const isSingleCandle = (idxEntry === idxExit);

                    let boxXLeft, boxXRight;
                    let lineXStart, lineXEnd;

                    if (isSingleCandle) {
                        // Single Candle: Box auf 1.0 Breite aufblasen (-0.5 bis +0.5)
                        boxXLeft = idxEntry - 0.5;
                        boxXRight = idxEntry + 0.5;
                        
                        // Diagonale auch über die ganze Breite ziehen
                        lineXStart = idxEntry - 0.5;
                        lineXEnd = idxEntry + 0.5;
                    } else {
                        // Multi Candle: Exakt Mitte zu Mitte (kein Offset)
                        boxXLeft = Math.min(idxEntry, idxExit);
                        boxXRight = Math.max(idxEntry, idxExit);
                        
                        // Linie exakt von Entry-Index zu Exit-Index
                        lineXStart = idxEntry;
                        lineXEnd = idxExit;
                    }

                    // --- SL-Box ---
                    if (!Number.isNaN(slPrice)) {
                        const yLow  = Math.min(entryPrice, slPrice);
                        const yHigh = Math.max(entryPrice, slPrice);
                        const xSl = [boxXLeft, boxXRight, boxXRight, boxXLeft, boxXLeft];
                        const ySl = [yHigh, yHigh, yLow, yLow, yHigh];

                        traces.push({
                            type: "scatter",
                            x: xSl,
                            y: ySl,
                            mode: "lines",
                            line: { width: 0 },
                            fill: "toself",
                            fillcolor: "rgba(8,153,129,0.15)", 
                            hoverinfo: "skip",
                            showlegend: false
                        });
                    }

                    // --- TP-Box ---
                    if (!Number.isNaN(tpPrice)) {
                        const yLow  = Math.min(entryPrice, tpPrice);
                        const yHigh = Math.max(entryPrice, tpPrice);
                        const xTp = [boxXLeft, boxXRight, boxXRight, boxXLeft, boxXLeft];
                        const yTp = [yHigh, yHigh, yLow, yLow, yHigh];

                        traces.push({
                            type: "scatter",
                            x: xTp,
                            y: yTp,
                            mode: "lines",
                            line: { width: 0 },
                            fill: "toself",
                            fillcolor: "rgba(67,70,81,0.15)", 
                            hoverinfo: "skip",
                            showlegend: false
                        });
                    }

                    // --- PnL-Box ---
                    if (entryPrice !== exitPrice) {
                        const yLow  = Math.min(entryPrice, exitPrice);
                        const yHigh = Math.max(entryPrice, exitPrice);
                        const isProfit = isBuy ? (exitPrice > entryPrice) : (exitPrice < entryPrice);
                        const fillProfit = "rgba(67,70,81,0.15)";  
                        const fillLoss   = "rgba(8,153,129,0.15)"; 

                        const xPnL = [boxXLeft, boxXRight, boxXRight, boxXLeft, boxXLeft];
                        const yPnL = [yHigh, yHigh, yLow, yLow, yHigh];

                        traces.push({
                            type: "scatter",
                            x: xPnL,
                            y: yPnL,
                            mode: "lines",
                            line: { width: 0 },
                            fill: "toself",
                            fillcolor: isProfit ? fillProfit : fillLoss,
                            hoverinfo: "skip",
                            showlegend: false
                        });
                    }

                    // --- Diagonale Entry -> Exit ---
                    // Nutzt jetzt lineXStart/End, um bei Single-Candle diagonal zu verlaufen
                    traces.push({
                        type: "scatter",
                        x: [lineXStart, lineXEnd],
                        y: [entryPrice, exitPrice],
                        mode: "lines",
                        line: {
                            width: 1,
                            color: "rgba(49,27,146,1.0)", 
                            dash: "dash"
                        },
                        hoverinfo: "skip",
                        showlegend: false
                    });

                    continue; 
                }

                // ---------------------------------------------------
                // FALL B: missed Trade -> nur Positions-Fenster (SL/TP)
                // ---------------------------------------------------
                let entryPrice = tr.entryPrice;
                if (!Number.isFinite(entryPrice)) continue;

                const slPrice = Number.isFinite(tr.slPrice) ? tr.slPrice : NaN;
                const tpPrice = Number.isFinite(tr.tpPrice) ? tr.tpPrice : NaN;

                const box = findPhase2BoxForTrade(tr);
                if (!box || !Number.isFinite(box.signalTs)) continue;

                let posSignal = findPosGEByTs(tfData, box.signalTs);
                if (posSignal === null) posSignal = findPosLEByTs(tfData, box.signalTs);
                if (posSignal === null) continue;

                const signalBarIdx = tfData.bars[posSignal].i;
                let startIdx = signalBarIdx + 1; 

                let endIdx = null;
                if (tr.entryWindowEndTs != null && Number.isFinite(tr.entryWindowEndTs)) {
                    let posFirstAfter = findPosGEByTs(tfData, tr.entryWindowEndTs);
                    if (posFirstAfter !== null) {
                        let posEnd = posFirstAfter - 1;
                        if (posEnd < 0) posEnd = 0;
                        endIdx = tfData.bars[posEnd].i;
                    }
                }
                if (endIdx === null) endIdx = maxIdx;
                if (endIdx < startIdx) {
                    const tmp = startIdx; startIdx = endIdx; endIdx = tmp;
                }

                const leftIdx  = Math.max(minIdx, startIdx);
                const rightIdx = Math.min(maxIdx, endIdx);
                if (rightIdx < minIdx || leftIdx > maxIdx || rightIdx < leftIdx) continue;

                // -----------------------------------------------------------
                // ÄNDERUNG: Offset-Logik für Single-Candle Missed Trades
                // -----------------------------------------------------------
                let boxXLeft = leftIdx;
                let boxXRight = rightIdx;

                if (leftIdx === rightIdx) {
                    // Wenn das Limit-Fenster nur 1 Kerze lang ist (oder durch Zoom so aussieht)
                    boxXLeft = leftIdx - 0.5;
                    boxXRight = rightIdx + 0.5;
                }

                // --- SL-Box (Limitfenster) ---
                if (!Number.isNaN(slPrice)) {
                    const yLow  = Math.min(entryPrice, slPrice);
                    const yHigh = Math.max(entryPrice, slPrice);
                    const xSl = [boxXLeft, boxXRight, boxXRight, boxXLeft, boxXLeft];
                    const ySl = [yHigh, yHigh, yLow, yLow, yHigh];

                    traces.push({
                        type: "scatter",
                        x: xSl,
                        y: ySl,
                        mode: "lines",
                        line: { width: 0 },
                        fill: "toself",
                        fillcolor: "rgba(8,153,129,0.15)", 
                        hoverinfo: "skip",
                        showlegend: false
                    });
                }

                // --- TP-Box (Limitfenster) ---
                if (!Number.isNaN(tpPrice)) {
                    const yLow  = Math.min(entryPrice, tpPrice);
                    const yHigh = Math.max(entryPrice, tpPrice);
                    const xTp = [boxXLeft, boxXRight, boxXRight, boxXLeft, boxXLeft];
                    const yTp = [yHigh, yHigh, yLow, yLow, yHigh];

                    traces.push({
                        type: "scatter",
                        x: xTp,
                        y: yTp,
                        mode: "lines",
                        line: { width: 0 },
                        fill: "toself",
                        fillcolor: "rgba(67,70,81,0.15)", 
                        hoverinfo: "skip",
                        showlegend: false
                    });
                }
            }

            return traces;
        }

        // -----------------------------------------------------------
        // 5) Figure bauen
        // -----------------------------------------------------------
        function buildFigureForState(tf, tfData, state, yRange, autoY, chartPixelWidth, pane) {
            const { windowStart, windowEnd, visibleStartIdx, visibleEndIdx } = state;

            if (windowEnd < windowStart) {
                return {
                    fig: {
                        data: [],
                        layout: {
                            title: `${tf} – no data`,
                            plot_bgcolor: BACKGROUND_COLOR,
                            paper_bgcolor: BACKGROUND_COLOR,
                        },
                        config: PLOT_CONFIG
                    },
                    visibleTimeRange: null,
                    usedYRange: yRange
                };
            }

            const windowBars = sliceBarsForRange(tfData, windowStart, windowEnd);
            const visibleBarsArr = sliceBarsForRange(tfData, visibleStartIdx, visibleEndIdx);

            const x = [], open = [], high = [], low = [], close = [], customdata = [];

            let yMin = (yRange && !autoY) ? yRange[0] : Number.POSITIVE_INFINITY;
            let yMax = (yRange && !autoY) ? yRange[1] : Number.NEGATIVE_INFINITY;

            for (const bar of windowBars) {
                x.push(bar.i);
                open.push(bar.o);
                high.push(bar.h);
                low.push(bar.l);
                close.push(bar.c);

                const ts = new Date(bar.ts);
                const wdIdx = ts.getUTCDay();
                const wdNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
                const wd = wdNames[wdIdx] || "";
                const monthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
                const mm = monthNames[ts.getUTCMonth()];
                const year2 = String(ts.getUTCFullYear()).slice(-2);

                const dd = String(ts.getUTCDate()).padStart(2, "0");
                const hh = String(ts.getUTCHours()).padStart(2, "0");
                const mi = String(ts.getUTCMinutes()).padStart(2, "0");

                const label = `${wd} ${dd} ${mm} '${year2} ${hh}:${mi}`;

                // WICHTIG: hier jetzt Objekt mit label UND ts
                customdata.push({
                    label: label,
                    ts: bar.ts  // dein Original-Timestamp (ms since epoch)
                });
            }

            if (autoY || !yRange) {
                for (const bar of visibleBarsArr) {
                    if (bar.l < yMin) yMin = bar.l;
                    if (bar.h > yMax) yMax = bar.h;
                }
                if (!Number.isFinite(yMin) || !Number.isFinite(yMax)) {
                    yMin = Number.POSITIVE_INFINITY;
                    yMax = Number.NEGATIVE_INFINITY;
                    for (const bar of windowBars) {
                        if (bar.l < yMin) yMin = bar.l;
                        if (bar.h > yMax) yMax = bar.h;
                    }
                }
            }

            const viewStart = (state.viewStart != null)
                ? state.viewStart
                : (visibleStartIdx - 0.5);

            const viewEnd = (state.viewEnd != null)
                ? state.viewEnd
                : (visibleEndIdx + 0.5);

            const xRange = [viewStart, viewEnd];
            const finalYRange = [yMin, yMax];

            let visibleTimeRange = null;
            if (visibleBarsArr.length > 0) {
                const leftTime = visibleBarsArr[0].t;
                const rightTime = visibleBarsArr[visibleBarsArr.length - 1].t;
                visibleTimeRange = [leftTime, rightTime];
            }

            const tickInfo = computeTimeTicks(tf, tfData, state, chartPixelWidth);
            const tickvals = tickInfo.tickvals;
            const ticktext = tickInfo.ticktext;

            // ---------------- Eigene Tick-Striche als Shapes ----------------
            const shapes = [];
            const tickLabels = (Array.isArray(ticktext) && Array.isArray(tickvals) && ticktext.length === tickvals.length)
                ? ticktext
                : null;

            if (tickLabels) {
                for (let i = 0; i < tickvals.length; i++) {
                    const tv = tickvals[i];
                    const txt = tickLabels[i];

                    // Nur dort einen Strich zeichnen, wo auch ein Label angezeigt wird.
                    if (!txt) continue;

                    shapes.push({
                        type: "line",
                        xref: "x",
                        yref: "paper",
                        x0: tv,
                        x1: tv,
                        y0: 0,
                        y1: -0.006,
                        line: {
                            color: FOREGROUND_COLOR,
                            width: 1
                        },
                        layer: "above"
                    });
                }
            }

            // Haupt-Candlestick-Trace
            const priceTrace = {
                type: "candlestick",
                x, open, high, low, close,
                customdata,
                name: "Price",
                increasing: {
                    line: { color: WICK_OUTLINE_COLOR },
                    fillcolor: BULL_BODY_COLOR
                },
                decreasing: {
                    line: { color: WICK_OUTLINE_COLOR },
                    fillcolor: BEAR_BODY_COLOR
                },
                line: { width: 1 },
                hoverinfo: candleHoverOn ? "x+y" : "none",
                showlegend: false
            };

            // Session-Polygone (unter allem)
            const sessionTraces = buildSessionTraces(tf, tfData, state, windowBars, visibleBarsArr);

            // Phase2-Boxen
            const phase2Traces = buildPhase2Traces(tf, tfData, windowBars, windowStart, windowEnd, pane);

            // Phase3-Trades
            const phase3Traces = buildPhase3Traces(tf, tfData, windowBars, windowStart, windowEnd, pane);

            const allTraces = []
                .concat(sessionTraces)
                .concat(phase2Traces)
                .concat(phase3Traces)
                .concat([priceTrace]);

            // Pane-spezifische Einstellungen
            let yAxisSide;
            let margin;

            if (pane === "left") {
                // Linker Chart: Y-Achse links, rechts wenig Margin
                yAxisSide = "left";
                margin = { l: 60, r: 10, t: 20, b: 40 };
            } else {
                // Rechter Chart (oder Fallback): Y-Achse rechts, links wenig Margin
                yAxisSide = "right";
                margin = { l: 10, r: 60, t: 20, b: 40 };
            }

            const layout = {
                title: `${DATA.symbol} – ${tf} (NY)`,
                xaxis: {
                    title: "",
                    rangeslider: { visible: false },
                    showgrid: false,
                    showline: true,
                    linewidth: 1,
                    linecolor: "black",
                    mirror: true,

                    ticks: "outside",
                    ticklen: 5,
                    tickcolor: BACKGROUND_COLOR,
                    tickpadding: 5,

                    fixedrange: axisMode === "y",
                    range: xRange,
                    tickmode: (tickvals && tickvals.length) ? "array" : "auto",
                    tickvals: (tickvals && tickvals.length) ? tickvals : undefined,
                    ticktext: (ticktext && ticktext.length) ? ticktext : undefined,
                },
                yaxis: {
                    side: yAxisSide,
                    tickformat: ".5f",
                    showgrid: false,
                    showline: true,
                    linewidth: 1,
                    linecolor: "black",
                    mirror: true,
                    ticks: "outside",
                    fixedrange: axisMode === "x",
                    range: finalYRange,
                },
                hovermode: "x",
                dragmode: "pan",
                plot_bgcolor: BACKGROUND_COLOR,
                paper_bgcolor: BACKGROUND_COLOR,
                font: {
                    color: FOREGROUND_COLOR,
                    size: 11
                },
                shapes: shapes,
                margin: margin,
                showlegend: false
            };

            return {
                fig: { data: allTraces, layout, config: PLOT_CONFIG },
                visibleTimeRange,
                usedYRange: finalYRange
            };
        }

        // -----------------------------------------------------------
        // Phase2/Phase3: Dateiverzeichnis scannen & Dropdowns aktualisieren
        // -----------------------------------------------------------

        // HINWEIS: Diese Funktion geht davon aus, dass dein Webserver für "data/"
        // ein HTML-Directory-Listing liefert (z.B. einfacher File-Server, nginx autoindex, ...).
        // Falls das nicht so ist, kannst du alternativ eine kleine phase_files.json ausgeben
        // und die Funktion entsprechend anpassen.
        async function scanPhaseFiles() {
            try {
                const res = await fetch(DATA_DIR_URL, { cache: "no-store" });
                if (!res.ok) {
                    console.warn("Phase file scan failed:", res.status);
                    return;
                }
                const html = await res.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, "text/html");
                const links = Array.from(doc.querySelectorAll("a[href]"));
                const files = links
                    .map(a => a.getAttribute("href"))
                    .filter(href => href && !href.endsWith("/"));

                // ÄNDERUNG: Flexiblere Erkennung für Phase 2
                // Erkennt alles, was "_setups_" im Namen hat und auf .csv endet
                const phase2 = files.filter(name => /_setups_.*\.csv$/i.test(name) || name.endsWith("_setups.csv")).sort();
                
                // Phase 3 bleibt gleich (erkennt _trades_)
                const phase3 = files.filter(name => /_trades_.*\.csv$/i.test(name)).sort();

                updatePhaseDropdowns(phase2, phase3);
            } catch (e) {
                console.warn("Phase file scan error:", e);
            }
        }

        function updatePhaseDropdowns(newPhase2Files, newPhase3Files) {
            const p2Select = document.getElementById("phase2-file-select");
            const p3Select = document.getElementById("phase3-file-select");
            if (!p2Select || !p3Select) return;

            const oldP2 = phase2Files.slice();
            const oldP3 = phase3Files.slice();

            phase2Files = newPhase2Files || [];
            phase3Files = newPhase3Files || [];

            // aktuell ausgewählte Werte merken
            const currentP2 = phase2File;
            const currentP3 = phase3File;

            // Phase2-Select neu aufbauen
            p2Select.innerHTML = "";
            if (!phase2Files.length) {
                const opt = document.createElement("option");
                opt.value = "";
                opt.textContent = "(no setups files found)";
                p2Select.appendChild(opt);
                phase2File = null;
            } else {
                phase2Files.forEach(fn => {
                    const opt = document.createElement("option");
                    opt.value = fn;
                    opt.textContent = fn;
                    p2Select.appendChild(opt);
                });
                if (currentP2 && phase2Files.includes(currentP2)) {
                    phase2File = currentP2;
                } else {
                    // default: erste Datei wie im Python initial_phase2_file()
                    phase2File = phase2Files[0];
                }
                p2Select.value = phase2File || "";
            }

            // Phase3-Select neu aufbauen
            p3Select.innerHTML = "";
            if (!phase3Files.length) {
                const opt = document.createElement("option");
                opt.value = "";
                opt.textContent = "(no trades files found)";
                p3Select.appendChild(opt);
                phase3File = null;
            } else {
                phase3Files.forEach(fn => {
                    const opt = document.createElement("option");
                    opt.value = fn;
                    opt.textContent = fn;
                    p3Select.appendChild(opt);
                });
                if (currentP3 && phase3Files.includes(currentP3)) {
                    phase3File = currentP3;
                } else {
                    phase3File = phase3Files[0];
                }
                p3Select.value = phase3File || "";
            }
        }

        // Hilfsfunktion: aktuelle View mit neuen Phase2/3-Daten neu rendern
        function rerenderCurrentViewWithPhases() {
            if (!DATA || !DATA.timeframes) return;

            // Rechter (LTF) Chart
            if (DATA.timeframes[currentTf]) {
                const tfDataR = DATA.timeframes[currentTf];
                let stateR = TF_STATE[currentTf];
                if (!stateR) {
                    stateR = computeWindowForTf(tfDataR, DEFAULT_VISIBLE_BARS, tfDataR.maxIdx);
                }
                const regimeR = getRegime(currentTf);
                const regStateR = REGIME_STATE[regimeR] || {};

                applyStateAndRender(currentTf, stateR, {
                    autoY: false,
                    yRangeOverride: regStateR.yRange
                });
            }

            // Linker (HTF) Chart
            if (VIEW_MODE === VIEW_MODE_SPLIT && DATA.timeframes[currentTfLeft]) {
                const tfDataL = DATA.timeframes[currentTfLeft];
                let stateL = TF_STATE_LEFT[currentTfLeft];
                if (!stateL) {
                    stateL = computeWindowForTf(tfDataL, DEFAULT_VISIBLE_BARS, tfDataL.maxIdx);
                }
                const regimeL = getRegime(currentTfLeft, "left");
                const regStateL = REGIME_STATE_LEFT[regimeL] || {};

                applyStateAndRenderLeft(currentTfLeft, stateL, {
                    autoY: false,
                    yRangeOverride: regStateL.yRange
                });
            }
        }

        // Startet den periodischen Scan + Autoload
        function startPhaseScanLoop() {
            if (phaseScanTimer) {
                clearInterval(phaseScanTimer);
                phaseScanTimer = null;
            }

            // Initialer Scan + Load
            (async () => {
                await scanPhaseFiles();
                const p2Changed = await loadPhase2File(phase2File);
                const p3Changed = await loadPhase3File(phase3File);
                if (p2Changed || p3Changed) {
                    rerenderCurrentViewWithPhases();
                    rebuildSetupsList();
                }

            })();

            // Regelmäßiger Scan (Dateiliste + Re-Load der gewählten Dateien)
            phaseScanTimer = setInterval(async () => {
                await scanPhaseFiles();
                const p2Changed = await loadPhase2File(phase2File);
                const p3Changed = await loadPhase3File(phase3File);
                if (p2Changed || p3Changed) {
                    rerenderCurrentViewWithPhases();
                    rebuildSetupsList();
                }
            }, PHASE_FILE_SCAN_INTERVAL_MS);
        }


        // -----------------------------------------------------------
        // 6) Rendering / State-Update
        // -----------------------------------------------------------
        function applyStateAndRenderForPane(pane, tf, state, options) {
            // ... (Datenselektion Logik bleibt gleich) ...
            let tfData;
            if (pane === "left") {
                if (HTF_SNAPSHOT_ACTIVE && HTF_SNAPSHOT_TFDATA && HTF_SNAPSHOT_INFO && HTF_SNAPSHOT_INFO.tf === tf) {
                    tfData = HTF_SNAPSHOT_TFDATA;
                } else if (HTF_FOLLOW_ACTIVE && HTF_FOLLOW_TFDATA && HTF_FOLLOW_INFO && HTF_FOLLOW_INFO.tf === tf) {
                    tfData = HTF_FOLLOW_TFDATA;
                } else {
                    tfData = DATA.timeframes[tf];
                }
            } else {
                tfData = DATA.timeframes[tf];
            }

            if (!tfData) return;

            const regime = getRegime(tf);
            const regStateAll = (pane === "left") ? REGIME_STATE_LEFT : REGIME_STATE;
            const regState = regStateAll[regime];

            const autoY = !!options.autoY;
            let yRange = null;
            if (options.yRangeOverride) {
                yRange = options.yRangeOverride.slice();
            } else if (regState.yRange && !autoY) {
                yRange = regState.yRange.slice();
            }

            const chartId = (pane === "left") ? "htf-chart" : "m1-chart";

            let chartPixelWidth = null;
            const chartEl = document.getElementById(chartId);
            if (chartEl) {
                const rect = chartEl.getBoundingClientRect();
                if (rect && rect.width) {
                    chartPixelWidth = rect.width;
                } else {
                    chartPixelWidth = chartEl.clientWidth || chartEl.offsetWidth || null;
                }
            }

            const { fig, visibleTimeRange, usedYRange } = buildFigureForState(
                tf,
                tfData,
                state,
                yRange,
                autoY,
                chartPixelWidth,
                pane
            );

            if (pane === "left") {
                TF_STATE_LEFT[tf] = { ...state };
            } else {
                TF_STATE[tf] = { ...state };
            }

            if (visibleTimeRange) {
                regState.timeRange = visibleTimeRange;
                regState.anchorTime = visibleTimeRange[1];
            }
            if (usedYRange) regState.yRange = usedYRange.slice();
            regState.visibleBarsHint = state.visibleBars;
            if (autoY && !regState.initialized) regState.initialized = true;

            isRelayoutFromCode = true;
            Plotly.react(chartId, fig.data, fig.layout, fig.config)
                .then(() => {
                    isRelayoutFromCode = false;
                    savePersistentState();
                })
                .catch((e) => {
                    isRelayoutFromCode = false;
                    console.warn("Plotly.react error:", e);
                });
        }

        // Wrapper: rechter (LTF) Chart
        function applyStateAndRender(tf, state, options) {
            applyStateAndRenderForPane("right", tf, state, options);
        }

        // Wrapper: linker (HTF) Chart
        function applyStateAndRenderLeft(tf, state, options) {
            applyStateAndRenderForPane("left", tf, state, options);
        }

        function initDefaultViewRight() {
            const tfData = DATA.timeframes[currentTf];
            if (!tfData) return;
            const anchorIdx = tfData.maxIdx;
            const state = computeWindowForTfRightAnchored(tfData, DEFAULT_VISIBLE_BARS, anchorIdx);
            applyStateAndRender(currentTf, state, { autoY: true });
        }

        // Generischer Reanchor für linken ODER rechten Chart
        function reanchorChartToRightEdgeForPane(pane, widthFactor) {
            if (!DATA || !DATA.timeframes) return;

            const tf = pane === "left" ? currentTfLeft : currentTf;
            const tfData = DATA.timeframes[tf];
            if (!tfData) return;

            let state = pane === "left" ? TF_STATE_LEFT[tf] : TF_STATE[tf];
            if (!state) {
                const anchorIdxDefault = tfData.maxIdx;
                state = computeWindowForTfRightAnchored(
                    tfData,
                    DEFAULT_VISIBLE_BARS,
                    anchorIdxDefault
                );
            }

            let anchorIdx = state.visibleEndIdx;
            if (anchorIdx == null || !isFinite(anchorIdx)) {
                anchorIdx = state.visibleStartIdx;
            }
            if (anchorIdx == null || !isFinite(anchorIdx)) {
                anchorIdx = tfData.maxIdx;
            }

            let visibleBars = state.visibleBars || DEFAULT_VISIBLE_BARS;
            if (widthFactor && isFinite(widthFactor) && widthFactor > 0) {
                visibleBars = Math.round(visibleBars * widthFactor);
                if (visibleBars < 10) visibleBars = 10;
            }

            const newState = computeWindowForTfRightAnchored(
                tfData,
                visibleBars,
                anchorIdx
            );

            const regime = getRegime(tf);
            const regStateAll = pane === "left" ? REGIME_STATE_LEFT : REGIME_STATE;
            const regState = regStateAll[regime] || {};

            if (pane === "left") {
                applyStateAndRenderLeft(tf, newState, {
                    autoY: false,
                    yRangeOverride: regState.yRange
                });
            } else {
                applyStateAndRender(tf, newState, {
                    autoY: false,
                    yRangeOverride: regState.yRange
                });
            }
        }

        // Baut/aktualisiert den HTF-Follow-Snapshot auf Basis des rechten LTF-Endes
        function updateHtfFollowFromLtf(stateRight) {
            if (!DATA || !DATA.timeframes) return;
            if (VIEW_MODE !== VIEW_MODE_SPLIT) return;
            if (HTF_BEHAVIOR === HTF_BEHAVIOR_INDEPENDENT) return;
            if (!stateRight) return;

            const tfRight = currentTf;
            const tfLeft  = currentTfLeft;

            const tfDataRight        = DATA.timeframes[tfRight];
            const tfDataLeftOriginal = DATA.timeframes[tfLeft];
            const m1Data             = DATA.timeframes["M1"];

            if (!tfDataRight || !tfDataLeftOriginal || !m1Data) return;
            if (stateRight.visibleEndIdx == null) return;

            // Letzte sichtbare LTF-Kerze
            let lastIdx = stateRight.visibleEndIdx;
            if (!isFinite(lastIdx)) return;

            lastIdx = Math.round(lastIdx);
            lastIdx = Math.max(tfDataRight.minIdx, Math.min(tfDataRight.maxIdx, lastIdx));

            const barsRight = tfDataRight.bars || [];
            const posRight  = lastIdx - tfDataRight.minIdx;

            if (posRight < 0 || posRight >= barsRight.length) return;

            const lastBarRight = barsRight[posRight];
            if (!lastBarRight) return;

            const lastTs   = lastBarRight.ts;
            const ltfDurMs = timeframeToMs(tfRight);
            if (!ltfDurMs) return;

            const snapshotTime = lastTs + ltfDurMs;

            const snapshot = buildHtfSnapshotData(tfLeft, tfDataLeftOriginal, m1Data, snapshotTime);
            if (!snapshot) return;

            const { htfSnapshotData, htfBarIndex } = snapshot;

            const minIdx = htfSnapshotData.minIdx;
            const maxIdx = htfSnapshotData.maxIdx;

            // bisheriger State des linken Charts
            const prevState = TF_STATE_LEFT[tfLeft];

            // aktuelle Zoom-Stufe beibehalten, wenn möglich
            let visibleBars;
            if (prevState && prevState.visibleBars && prevState.visibleBars > 0) {
                visibleBars = prevState.visibleBars;
            } else if (stateRight.visibleBars && stateRight.visibleBars > 0) {
                visibleBars = stateRight.visibleBars;
            } else {
                visibleBars = DEFAULT_VISIBLE_BARS;
            }
            visibleBars = Math.max(1, Math.round(visibleBars));

            // "Soll"-Gap: 10 % der sichtbaren Breite (in Bar-Einheiten)
            const targetGapBars = Math.max(1, Math.round(visibleBars * 0.1));

            // aktueller Abstand der NEUEN HTF-Candle zum rechten Rand der bisherigen View
            let currentGapBars = null;
            if (prevState && prevState.viewEnd != null) {
                const rawGap = prevState.viewEnd - (htfBarIndex + 0.5);
                if (isFinite(rawGap) && rawGap > 0) {
                    currentGapBars = rawGap;
                } else {
                    currentGapBars = 0;
                }
            }

            const regimeLeft   = getRegime(tfLeft, "left");
            const regStateLeft = REGIME_STATE_LEFT[regimeLeft] || {};

            function renderWith(newState) {
                HTF_FOLLOW_ACTIVE = true;
                HTF_FOLLOW_TFDATA = htfSnapshotData;
                HTF_FOLLOW_INFO   = { tf: tfLeft, snapshotTime, htfBarIndex };

                applyStateAndRenderLeft(tfLeft, newState, {
                    autoY: false,
                    yRangeOverride: regStateLeft.yRange
                });
            }

            const hasEnoughGap = currentGapBars !== null && currentGapBars >= targetGapBars;

            // --------------------------------------------------------
            // FALL A: Es ist schon mindestens 10 % Platz vorhanden
            //         -> View NICHT pannen, nur Datenbasis aktualisieren.
            // --------------------------------------------------------
            if (prevState && hasEnoughGap) {
                let visStart = prevState.visibleStartIdx != null
                    ? prevState.visibleStartIdx
                    : (htfBarIndex - (visibleBars - 1));
                let visEnd   = prevState.visibleEndIdx != null
                    ? prevState.visibleEndIdx
                    : htfBarIndex;

                // auf neue Datenrange clampen
                visStart = Math.max(minIdx, Math.min(visStart, maxIdx));
                visEnd   = Math.max(minIdx, Math.min(visEnd,   maxIdx));

                if (visEnd < visStart) {
                    visStart = Math.max(minIdx, htfBarIndex - (visibleBars - 1));
                    visEnd   = Math.min(maxIdx, htfBarIndex);
                }

                visibleBars = Math.max(1, Math.round(visEnd - visStart + 1));
                const centerIdx = 0.5 * (visStart + visEnd);

                let newState = computeWindowForTf(htfSnapshotData, visibleBars, centerIdx);

                newState.visibleStartIdx = visStart;
                newState.visibleEndIdx   = visEnd;
                newState.visibleBars     = visibleBars;

                // X-View unverändert übernehmen, damit nichts springt
                newState.viewStart = prevState.viewStart != null
                    ? prevState.viewStart
                    : (visStart - 0.5);
                newState.viewEnd = prevState.viewEnd != null
                    ? prevState.viewEnd
                    : (visEnd + 0.5 + targetGapBars);

                renderWith(newState);
                return;
            }

            // --------------------------------------------------------
            // FALL B: Platz würde < 10 % werden
            //         -> wie bisher pannen, damit wieder min. 10 % Gap.
            // --------------------------------------------------------
            let visibleEndIdx   = htfBarIndex;
            let visibleStartIdx = visibleEndIdx - (visibleBars - 1);

            if (visibleStartIdx < minIdx) {
                visibleStartIdx = minIdx;
                visibleEndIdx   = visibleStartIdx + (visibleBars - 1);
                if (visibleEndIdx > maxIdx) visibleEndIdx = maxIdx;
            }
            if (visibleEndIdx > maxIdx) {
                visibleEndIdx   = maxIdx;
                visibleStartIdx = visibleEndIdx - (visibleBars - 1);
                if (visibleStartIdx < minIdx) visibleStartIdx = minIdx;
            }

            visibleBars = Math.max(1, visibleEndIdx - visibleStartIdx + 1);
            const centerIdx = 0.5 * (visibleStartIdx + visibleEndIdx);

            let newState = computeWindowForTf(htfSnapshotData, visibleBars, centerIdx);

            newState.visibleStartIdx = visibleStartIdx;
            newState.visibleEndIdx   = visibleEndIdx;
            newState.visibleBars     = visibleBars;

            // bisherigen Gap (in "Bar-Breiten") aus dem alten State holen
            let prevGapBars = 0;
            if (
                prevState &&
                prevState.viewEnd != null &&
                prevState.visibleEndIdx != null
            ) {
                const rawGapPrev = prevState.viewEnd - (prevState.visibleEndIdx + 0.5);
                if (isFinite(rawGapPrev) && rawGapPrev > 0) {
                    prevGapBars = rawGapPrev;
                }
            }

            // neuer Gap = mindestens 10 %, aber nicht kleiner als vorher
            const gapBars = Math.max(targetGapBars, prevGapBars);

            newState.viewStart = visibleStartIdx - 0.5;
            newState.viewEnd   = visibleEndIdx + 0.5 + gapBars;

            renderWith(newState);
        }

        // Bestehender Wrapper für den rechten Chart
        function reanchorRightChartToRightEdge(widthFactor) {
            reanchorChartToRightEdgeForPane("right", widthFactor);
        }

        function initDefaultViewLeft() {
            if (!DATA || !DATA.timeframes) return;

            if (!DATA.timeframes[currentTfLeft]) {
                const available = Object.keys(DATA.timeframes);
                if (!available.length) return;
                currentTfLeft = available[0];
            }

            const tfData = DATA.timeframes[currentTfLeft];
            const anchorIdx = tfData.maxIdx;
            const state = computeWindowForTfRightAnchored(tfData, DEFAULT_VISIBLE_BARS, anchorIdx);
            applyStateAndRenderLeft(currentTfLeft, state, { autoY: true });
        }

        function updateLayoutForViewMode() {
            // ... (DOM Elemente holen - gleich wie vorher) ...
            const container = document.getElementById("chart-container");
            const leftWrap  = document.getElementById("left-chart-wrapper");
            const rightWrap = document.getElementById("right-chart-wrapper");
            const splitter  = document.getElementById("chart-splitter");
            const htfSection = document.getElementById("htf-tf-section");
            if (!rightWrap) return;

            // ... (Logik View Mode Switch - gleich wie vorher) ...
            if (VIEW_MODE === VIEW_MODE_SPLIT) {
                if (leftWrap) leftWrap.style.display = "block";
                if (splitter) splitter.style.display = "block";
                if (htfSection) htfSection.style.display = "flex";
                if (container && leftWrap && rightWrap) {
                    const containerRect = container.getBoundingClientRect();
                    const splitterRect  = splitter ? splitter.getBoundingClientRect() : null;
                    const splitterWidth = splitterRect && splitterRect.width ? splitterRect.width : 3;
                    const totalWidth    = containerRect.width || rightWrap.clientWidth + (leftWrap ? leftWrap.clientWidth : 0);
                    const usableWidth = Math.max(100, totalWidth - splitterWidth);
                    const leftPx  = usableWidth * SPLIT_LEFT_FRACTION;
                    const rightPx = usableWidth - leftPx;
                    leftWrap.style.flex  = `0 0 ${leftPx}px`;
                    rightWrap.style.flex = `0 0 ${rightPx}px`;
                }
                if (DATA && DATA.timeframes) {
                    if (!DATA.timeframes[currentTfLeft]) {
                        const available = Object.keys(DATA.timeframes);
                        if (available.length) currentTfLeft = available[0];
                    }
                    const tfDataL = DATA.timeframes[currentTfLeft];
                    if (tfDataL) {
                        let stateL = TF_STATE_LEFT[currentTfLeft];
                        const regimeL   = getRegime(currentTfLeft, "left");
                        const regStateL = REGIME_STATE_LEFT[regimeL] || {};
                        if (!stateL) {
                            stateL = computeWindowForTfRightAnchored(tfDataL, DEFAULT_VISIBLE_BARS, tfDataL.maxIdx);
                        }
                        applyStateAndRenderLeft(currentTfLeft, stateL, {
                            autoY: !regStateL.initialized,
                            yRangeOverride: regStateL.yRange
                        });
                    }
                }
            } else {
                if (leftWrap) leftWrap.style.display = "none";
                if (splitter) splitter.style.display = "none";
                rightWrap.style.flex = "1 1 100%";
                if (htfSection) htfSection.style.display = "none";
            }

            bindPlotlyEventsOnce();

            if (container) {
                const oldOverflowX = container.style.overflowX;
                const oldOverflowY = container.style.overflowY;
                container.style.overflowX = "hidden";
                container.style.overflowY = "hidden";

                window.requestAnimationFrame(() => {
                    try {
                        Plotly.Plots.resize("m1-chart");
                        if (VIEW_MODE === VIEW_MODE_SPLIT) {
                            Plotly.Plots.resize("htf-chart");
                        }
                    } catch (e) {
                        console.warn("Plotly resize after view mode change failed:", e);
                    } finally {
                        container.style.overflowX = oldOverflowX;
                        container.style.overflowY = oldOverflowY;
                    }
                });
            }
        }

        function initSplitterDrag() {
            // ... (Variablen etc. gleich) ...
            const container = document.getElementById("chart-container");
            const leftWrap  = document.getElementById("left-chart-wrapper");
            const rightWrap = document.getElementById("right-chart-wrapper");
            const splitter  = document.getElementById("chart-splitter");
            if (!container || !leftWrap || !rightWrap || !splitter) return;

            splitter.addEventListener("mousedown", (e) => {
                if (VIEW_MODE !== VIEW_MODE_SPLIT) return;
                e.preventDefault();
                const containerRect = container.getBoundingClientRect();
                const leftRect      = leftWrap.getBoundingClientRect();
                const rightRect     = rightWrap.getBoundingClientRect();
                const splitterRect  = splitter.getBoundingClientRect();
                splitterContainerWidth = containerRect.width;
                splitterStartLeftWidth  = leftRect.width;
                splitterStartRightWidth = rightRect.width;
                splitterWidthPx         = splitterRect.width;
                splitterStartX          = e.clientX;
                isSplitterDragging = true;
                document.body.style.cursor = "col-resize";
            });

            window.addEventListener("mousemove", (e) => {
                if (!isSplitterDragging) return;
                const delta = e.clientX - splitterStartX;
                const minWidth = 80;
                let newLeft = splitterStartLeftWidth + delta;
                const maxLeft = splitterContainerWidth - splitterWidthPx - minWidth;
                if (newLeft < minWidth) newLeft = minWidth;
                if (newLeft > maxLeft)  newLeft = maxLeft;
                const newRight = splitterContainerWidth - splitterWidthPx - newLeft;
                leftWrap.style.flex  = `0 0 ${newLeft}px`;
                rightWrap.style.flex = `0 0 ${newRight}px`;

                try {
                    Plotly.Plots.resize("m1-chart");
                } catch (err) {
                    console.warn("Plotly resize m1-chart failed:", err);
                }
                try {
                    if (VIEW_MODE === VIEW_MODE_SPLIT) {
                        Plotly.Plots.resize("htf-chart");
                    }
                } catch (err) {
                    console.warn("Plotly resize htf-chart failed:", err);
                }
            });

            window.addEventListener("mouseup", () => {
                if (!isSplitterDragging) return;
                isSplitterDragging = false;
                document.body.style.cursor = "";
                const leftRect  = leftWrap.getBoundingClientRect();
                const rightRect = rightWrap.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                const totalWidth = containerRect.width;
                const usableWidth = Math.max(1, totalWidth - splitterWidthPx);
                if (usableWidth > 0) {
                    let frac = leftRect.width / usableWidth;
                    frac = Math.min(0.9, Math.max(0.1, frac));
                    SPLIT_LEFT_FRACTION = frac;
                }
                if (splitterStartLeftWidth > 0 && leftRect.width > 0) {
                    const factorLeft = leftRect.width / splitterStartLeftWidth;
                    if (Math.abs(factorLeft - 1) > 0.01) {
                        reanchorChartToRightEdgeForPane("left", factorLeft);
                        try { Plotly.Plots.resize("htf-chart"); } catch (e) {}
                    }
                }
                if (splitterStartRightWidth > 0 && rightRect.width > 0) {
                    const factorRight = rightRect.width / splitterStartRightWidth;
                    if (Math.abs(factorRight - 1) > 0.01) {
                        reanchorChartToRightEdgeForPane("right", factorRight);
                        try { Plotly.Plots.resize("m1-chart"); } catch (e) {}
                    }
                }
                savePersistentState();
            });
        }

        // -----------------------------------------------------------
        // 7) Timeframe-Wechsel
        // -----------------------------------------------------------
        function onTfChange(newTf) {
            if (newTf === currentTf) return;

            const oldTf = currentTf;
            const oldRegime = getRegime(oldTf);
            const newRegime = getRegime(newTf);

            currentTf = newTf;

            const tfDataNew = DATA.timeframes[newTf];
            if (!tfDataNew) {
                console.warn("No data for TF", newTf);
                return;
            }

            // Falls nötig den rechten Chart für Phase 2 Referenz nutzen
            if (!PHASE2_BASE_TF) {
                getPhase2BaseTfData();
            }

            const regStateOld = REGIME_STATE[oldRegime];
            const regStateNew = REGIME_STATE[newRegime];

            if (oldRegime === newRegime) {
                const timeRange = regStateOld.timeRange;
                const yRange = regStateOld.yRange;
                
                // Basis-Berechnung anhand der Zeit
                const state = computeWindowFromTimeRangeExact(tfDataNew, timeRange);

                // --- GAP-FIX START ---
                // Wir übertragen das relative Verhältnis von Gap zu Datenbreite
                const oldState = TF_STATE[oldTf];
                if (oldState && oldState.visibleEndIdx != null && oldState.visibleStartIdx != null) {
                    const oldSpan = oldState.visibleEndIdx - oldState.visibleStartIdx;
                    const newSpan = state.visibleEndIdx - state.visibleStartIdx;

                    if (oldSpan > 0 && newSpan > 0) {
                        // 1. Gap Rechts (viewEnd > visibleEnd)
                        if (oldState.viewEnd != null) {
                            const oldBarEdgeR = oldState.visibleEndIdx + 0.5;
                            const oldGapR = oldState.viewEnd - oldBarEdgeR;
                            // Gap verhältnismäßig übertragen
                            const ratioR = oldGapR / oldSpan;
                            const newGapR = newSpan * ratioR;
                            
                            state.viewEnd = (state.visibleEndIdx + 0.5) + newGapR;
                        }

                        // 2. Gap Links (viewStart < visibleStart)
                        if (oldState.viewStart != null) {
                            const oldBarEdgeL = oldState.visibleStartIdx - 0.5;
                            const oldGapL = oldBarEdgeL - oldState.viewStart;
                            
                            const ratioL = oldGapL / oldSpan;
                            const newGapL = newSpan * ratioL;

                            state.viewStart = (state.visibleStartIdx - 0.5) - newGapL;
                        }
                    }
                }
                // --- GAP-FIX ENDE ---

                applyStateAndRender(newTf, state, { autoY: false, yRangeOverride: yRange });
                return;
            }

            const anchorTime = regStateOld.anchorTime;
            let anchorIdx = null;
            if (anchorTime && tfDataNew.bars && tfDataNew.bars.length) {
                const anchorTs = parseNyIsoToMs(anchorTime);
                const pos = findPosLEByTs(tfDataNew, anchorTs);
                if (pos !== null) anchorIdx = tfDataNew.bars[pos].i;
            }
            const visibleBars = regStateNew.visibleBarsHint && regStateNew.visibleBarsHint > 0 ? regStateNew.visibleBarsHint : DEFAULT_VISIBLE_BARS;
            const state = computeWindowForTfRightAnchored(tfDataNew, visibleBars, anchorIdx);
            if (!regStateNew.initialized) {
                applyStateAndRender(newTf, state, { autoY: true });
            } else {
                applyStateAndRender(newTf, state, { autoY: false, yRangeOverride: regStateNew.yRange });
            }
        }

        function onTfChangeLeft(newTf) {
            if (newTf === currentTfLeft) return;

            const wasSnapshotActive = HTF_SNAPSHOT_ACTIVE;
            const preservedSnapshotInfo = HTF_SNAPSHOT_INFO;
            const preservedMaxSignalTs = HTF_SNAPSHOT_MAX_SIGNAL_TS;

            clearHtfSnapshot();

            const oldTf = currentTfLeft;
            // NEU: Pane "left" übergeben!
            const oldRegime = getRegime(oldTf, "left");
            const newRegime = getRegime(newTf, "left");

            currentTfLeft = newTf;

            let tfDataNew = DATA.timeframes[newTf];
            if (!tfDataNew) {
                console.warn("No data for TF (left)", newTf);
                return;
            }

            const m1Data = DATA.timeframes["M1"];
            let snapshotRestored = false;

            // --- A) SNAPSHOT RESTORE ---
            if (wasSnapshotActive && preservedSnapshotInfo && preservedSnapshotInfo.snapshotTime && m1Data) {
                const snapshot = buildHtfSnapshotData(newTf, tfDataNew, m1Data, preservedSnapshotInfo.snapshotTime);
                if (snapshot) {
                    HTF_SNAPSHOT_ACTIVE = true;
                    HTF_SNAPSHOT_TFDATA = snapshot.htfSnapshotData;
                    HTF_SNAPSHOT_INFO = {
                        ...preservedSnapshotInfo,
                        tf: newTf,
                        htfBarIndex: snapshot.htfBarIndex
                    };
                    HTF_SNAPSHOT_MAX_SIGNAL_TS = preservedMaxSignalTs;
                    
                    if (preservedSnapshotInfo.setupId != null && SETUP_BY_ID) {
                        const setup = SETUP_BY_ID[String(preservedSnapshotInfo.setupId)];
                        if (setup && setup.boxRef) {
                            setup.boxRef.isSnapshotActive = true;
                        }
                    }
                    tfDataNew = HTF_SNAPSHOT_TFDATA;
                    snapshotRestored = true;
                }
            }

            // --- B) FOLLOW MODE ---
            if (!snapshotRestored) {
                const isFollowMode = (VIEW_MODE === VIEW_MODE_SPLIT && 
                                     (HTF_BEHAVIOR === HTF_BEHAVIOR_FOLLOW_SNAP || HTF_BEHAVIOR === HTF_BEHAVIOR_FOLLOW_STRICT));
                
                if (isFollowMode && TF_STATE[currentTf]) {
                    const stateRight = TF_STATE[currentTf];
                    const tfRight = currentTf;
                    
                    if (stateRight.visibleEndIdx != null) {
                        const tfDataRight = DATA.timeframes[tfRight];
                        if (tfDataRight && m1Data) {
                            let lastIdx = Math.round(stateRight.visibleEndIdx);
                            lastIdx = Math.max(tfDataRight.minIdx, Math.min(tfDataRight.maxIdx, lastIdx));
                            const posRight = lastIdx - tfDataRight.minIdx;
                            if (posRight >= 0 && posRight < tfDataRight.bars.length) {
                                const lastBarRight = tfDataRight.bars[posRight];
                                const ltfDurMs = timeframeToMs(tfRight);
                                if (lastBarRight && ltfDurMs) {
                                    const snapshotTime = lastBarRight.ts + ltfDurMs;
                                    const snapshot = buildHtfSnapshotData(newTf, DATA.timeframes[newTf], m1Data, snapshotTime);
                                    if (snapshot) {
                                        HTF_FOLLOW_ACTIVE = true;
                                        HTF_FOLLOW_TFDATA = snapshot.htfSnapshotData;
                                        HTF_FOLLOW_INFO = { 
                                            tf: newTf, 
                                            snapshotTime: snapshotTime, 
                                            htfBarIndex: snapshot.htfBarIndex 
                                        };
                                        tfDataNew = HTF_FOLLOW_TFDATA;
                                    }
                                }
                            }
                        }
                    }
                } else {
                    HTF_FOLLOW_ACTIVE = false;
                    HTF_FOLLOW_TFDATA = null;
                    HTF_FOLLOW_INFO = null;
                }
            }

            const regStateOld = REGIME_STATE_LEFT[oldRegime];
            const regStateNew = REGIME_STATE_LEFT[newRegime];

            if (oldRegime === newRegime) {
                const timeRange = regStateOld.timeRange;
                const yRange = regStateOld.yRange;
                const state = computeWindowFromTimeRangeExact(tfDataNew, timeRange);

                // Gap-Fix
                const oldState = TF_STATE_LEFT[oldTf];
                if (oldState && oldState.visibleEndIdx != null && oldState.visibleStartIdx != null) {
                    const oldSpan = oldState.visibleEndIdx - oldState.visibleStartIdx;
                    const newSpan = state.visibleEndIdx - state.visibleStartIdx;
                    if (oldSpan > 0 && newSpan > 0) {
                        if (oldState.viewEnd != null) {
                            const oldBarEdgeR = oldState.visibleEndIdx + 0.5;
                            const oldGapR = oldState.viewEnd - oldBarEdgeR;
                            const ratioR = oldGapR / oldSpan;
                            const newGapR = newSpan * ratioR;
                            state.viewEnd = (state.visibleEndIdx + 0.5) + newGapR;
                        }
                        if (oldState.viewStart != null) {
                            const oldBarEdgeL = oldState.visibleStartIdx - 0.5;
                            const oldGapL = oldBarEdgeL - oldState.viewStart;
                            const ratioL = oldGapL / oldSpan;
                            const newGapL = newSpan * ratioL;
                            state.viewStart = (state.visibleStartIdx - 0.5) - newGapL;
                        }
                    }
                }

                applyStateAndRenderLeft(newTf, state, { autoY: false, yRangeOverride: yRange });
                return;
            }

            const anchorTime = regStateOld.anchorTime;
            let anchorIdx = null;
            if (anchorTime && tfDataNew.bars && tfDataNew.bars.length) {
                const anchorTs = parseNyIsoToMs(anchorTime);
                const pos = findPosLEByTs(tfDataNew, anchorTs);
                if (pos !== null) anchorIdx = tfDataNew.bars[pos].i;
            }
            if (anchorIdx === null && tfDataNew.bars.length > 0) {
                anchorIdx = tfDataNew.maxIdx;
            }

            const visibleBars = regStateNew.visibleBarsHint && regStateNew.visibleBarsHint > 0 ? regStateNew.visibleBarsHint : DEFAULT_VISIBLE_BARS;
            const state = computeWindowForTfRightAnchored(tfDataNew, visibleBars, anchorIdx);
            
            if (!regStateNew.initialized) {
                applyStateAndRenderLeft(newTf, state, { autoY: true });
            } else {
                applyStateAndRenderLeft(newTf, state, { autoY: false, yRangeOverride: regStateNew.yRange });
            }
        }

        // Window aus Zeitbereich – EXAKT, ohne sichtbareBreite-Hints:
        function computeWindowFromTimeRangeExact(tfData, timeRange) {
            const bars = tfData.bars || [];
            if (!bars.length || !timeRange || timeRange.length !== 2) {
                return computeWindowForTf(tfData, DEFAULT_VISIBLE_BARS, null);
            }

            const [t0, t1] = timeRange;
            const ts0 = parseNyIsoToMs(t0);
            const ts1 = parseNyIsoToMs(t1);

            let posL = findPosGEByTs(tfData, ts0);
            let posR = findPosLEByTs(tfData, ts1);

            if (posL === null && posR === null) {
                return computeWindowForTf(tfData, DEFAULT_VISIBLE_BARS, null);
            }
            if (posL === null) posL = 0;
            if (posR === null) posR = bars.length - 1;
            if (posR < posL) {
                const tmp = posL;
                posL = posR;
                posR = tmp;
            }

            const leftIdx = bars[posL].i;
            const rightIdx = bars[posR].i;
            const visibleBars = Math.max(1, rightIdx - leftIdx + 1);

            const centerIdx = 0.5 * (leftIdx + rightIdx);
            return computeWindowForTf(tfData, visibleBars, centerIdx);
        }

        // -----------------------------------------------------------
        // 8) plotly_relayout -> dynamisches Re-Windowing (kein Auto-Y)
        // -----------------------------------------------------------
        let plotlyEventsBoundRight = false;
        let plotlyEventsBoundLeft = false;

        function handleRelayoutForPane(pane, ev) {
            if (isRelayoutFromCode) return;
            if (!DATA) return;

            const isLeft = (pane === "left");
            const tf = isLeft ? currentTfLeft : currentTf;

            // --- KORREKTUR START: Die richtige Datenquelle wählen ---
            let tfData = DATA.timeframes[tf];

            // Im linken Chart müssen wir prüfen, ob wir gerade einen Snapshot oder Follow-Modus anzeigen.
            // Sonst berechnen wir die Korrektur auf Daten, die der User gar nicht sieht.
            if (isLeft) {
                if (HTF_SNAPSHOT_ACTIVE && HTF_SNAPSHOT_TFDATA && HTF_SNAPSHOT_INFO && HTF_SNAPSHOT_INFO.tf === tf) {
                    tfData = HTF_SNAPSHOT_TFDATA;
                } else if (HTF_FOLLOW_ACTIVE && HTF_FOLLOW_TFDATA && HTF_FOLLOW_INFO && HTF_FOLLOW_INFO.tf === tf) {
                    tfData = HTF_FOLLOW_TFDATA;
                }
            }
            // --- KORREKTUR ENDE ---

            if (!tfData) return;

            const regime = getRegime(tf);
            const regStateAll = isLeft ? REGIME_STATE_LEFT : REGIME_STATE;
            const regState = regStateAll[regime];

            let hasX = false, hasY = false;
            let v0 = null, v1 = null, y0 = null, y1 = null;

            if (ev["xaxis.range[0]"] !== undefined && ev["xaxis.range[1]"] !== undefined) {
                v0 = parseFloat(ev["xaxis.range[0]"]);
                v1 = parseFloat(ev["xaxis.range[1]"]);
                if (isFinite(v0) && isFinite(v1)) hasX = true;
            }

            if (ev["yaxis.range[0]"] !== undefined && ev["yaxis.range[1]"] !== undefined) {
                y0 = parseFloat(ev["yaxis.range[0]"]);
                y1 = parseFloat(ev["yaxis.range[1]"]);
                if (isFinite(y0) && isFinite(y1)) hasY = true;
            }

            let state = isLeft ? TF_STATE_LEFT[tf] : TF_STATE[tf];
            if (!state) {
                state = computeWindowForTf(tfData, DEFAULT_VISIBLE_BARS, null);
            }

            // Wir merken uns hier, ob durch dieses Relayout der Snapshot stirbt
            let excludedSetupId = null;

            // --- X-Teil: View-Range (Plotly) vs. Daten-Range trennen ---
            if (hasX) {
                const minIdx = tfData.minIdx;
                const maxIdx = tfData.maxIdx;

                // Rohes View-Fenster von Plotly
                let viewStart = v0;
                let viewEnd   = v1;

                if (!isFinite(viewStart) || !isFinite(viewEnd)) {
                    viewStart = state.viewStart != null ? state.viewStart : (minIdx - 0.5);
                    viewEnd   = state.viewEnd   != null ? state.viewEnd   : (maxIdx + 0.5);
                }

                const dataBandStart = minIdx - 0.5;
                const dataBandEnd   = maxIdx + 0.5;

                let span = Math.abs(viewEnd - viewStart);
                if (span < 1e-6) span = 1;

                if (viewStart > dataBandEnd) {
                    viewEnd = dataBandEnd;
                    viewStart = viewEnd - span;
                } else if (viewEnd < dataBandStart) {
                    viewStart = dataBandStart;
                    viewEnd = viewStart + span;
                }

                if (viewStart === viewEnd) {
                    viewEnd = viewStart + 1;
                }

                const vLeft  = Math.min(viewStart, viewEnd);
                const vRight = Math.max(viewStart, viewEnd);

                let left  = Math.max(vLeft,  dataBandStart);
                let right = Math.min(vRight, dataBandEnd);

                if (right < left) {
                    state.viewStart = viewStart;
                    state.viewEnd   = viewEnd;
                } else {
                    let visibleStartIdx = left + 0.5;
                    let visibleEndIdx   = right - 0.5;
                    if (visibleEndIdx < visibleStartIdx) {
                        const tmp = visibleStartIdx;
                        visibleStartIdx = visibleEndIdx;
                        visibleEndIdx = tmp;
                    }

                    const approxVisibleBars = Math.max(
                        1,
                        Math.round(visibleEndIdx - visibleStartIdx + 1)
                    );
                    const centerIdx = 0.5 * (visibleStartIdx + visibleEndIdx);

                    let baseState = computeWindowForTf(tfData, approxVisibleBars, centerIdx);

                    baseState.visibleStartIdx = visibleStartIdx;
                    baseState.visibleEndIdx   = visibleEndIdx;
                    baseState.visibleBars     = Math.max(
                        1,
                        visibleEndIdx - visibleStartIdx + 1
                    );

                    baseState.viewStart = viewStart;
                    baseState.viewEnd   = viewEnd;

                    state = baseState;
                }
            }

            // --- Y-Teil: Range updaten ---
            let yRange = regState.yRange;
            if (hasY) {
                yRange = [y0, y1];
                regState.yRange = yRange.slice();
            }

            // --- NEU: Auto-Correction Check (Empty Chart Guard) ---
            // Jetzt nutzen wir "tfData", was oben korrekt auf Snapshot/Follow/Raw gesetzt wurde.
            if (yRange && state.visibleStartIdx != null && state.visibleEndIdx != null) {
                const correctedY = calculateVerticalCorrection(
                    tfData,
                    state.visibleStartIdx,
                    state.visibleEndIdx,
                    yRange
                );

                if (correctedY) {
                    yRange = correctedY;
                    regState.yRange = correctedY.slice(); // State updaten
                }
            }

            if (isLeft) {
                applyStateAndRenderLeft(tf, state, {
                    autoY: false,
                    yRangeOverride: yRange
                });
            } else {
                applyStateAndRender(tf, state, {
                    autoY: false,
                    yRangeOverride: yRange
                });
            }

            // --- Logic: Snapshot verwerfen (nur LTF Relevanz) ---
            if (
                !isLeft &&
                HTF_SNAPSHOT_ACTIVE &&
                HTF_SNAPSHOT_INFO &&
                HTF_SNAPSHOT_INFO.signalTs != null &&
                (HTF_BEHAVIOR === HTF_BEHAVIOR_INDEPENDENT ||
                 HTF_BEHAVIOR === HTF_BEHAVIOR_FOLLOW_SNAP)
            ) {
                const vs = state.visibleStartIdx;
                const ve = state.visibleEndIdx;

                let signalIdx = null;
                if (Number.isFinite(HTF_SNAPSHOT_INFO.signalTs)) {
                    const posSignal = findPosLEByTs(tfData, HTF_SNAPSHOT_INFO.signalTs);
                    if (posSignal !== null) {
                        signalIdx = tfData.bars[posSignal].i;
                    }
                }

                if (
                    signalIdx != null &&
                    vs != null &&
                    ve != null &&
                    (signalIdx < vs || signalIdx > ve)
                ) {
                    const tfLeft = currentTfLeft;
                    const prevSetupId = HTF_SNAPSHOT_INFO ? HTF_SNAPSHOT_INFO.setupId : null;
                    excludedSetupId = prevSetupId;

                    clearHtfSnapshot({ clearSetupSelect: true });

                    if (DATA && DATA.timeframes && DATA.timeframes[tfLeft]) {
                        const tfDataLeft = DATA.timeframes[tfLeft];
                        let stateLeft = TF_STATE_LEFT[tfLeft];

                        if (!stateLeft) {
                            stateLeft = computeWindowForTfRightAnchored(
                                tfDataLeft,
                                DEFAULT_VISIBLE_BARS,
                                tfDataLeft.maxIdx
                            );
                        } else {
                            const { visibleStartIdx, visibleEndIdx, viewStart, viewEnd } = stateLeft;

                            if (visibleStartIdx != null && visibleEndIdx != null) {
                                const visibleBars = Math.max(1, Math.round(visibleEndIdx - visibleStartIdx + 1));
                                const centerIdx   = 0.5 * (visibleStartIdx + visibleEndIdx);
                                const recomputed = computeWindowForTf(tfDataLeft, visibleBars, centerIdx);

                                if (viewStart != null && viewEnd != null) {
                                    recomputed.viewStart = viewStart;
                                    recomputed.viewEnd   = viewEnd;
                                }
                                stateLeft = recomputed;
                            } else {
                                stateLeft = computeWindowForTfRightAnchored(
                                    tfDataLeft,
                                    DEFAULT_VISIBLE_BARS,
                                    tfDataLeft.maxIdx
                                );
                            }
                        }

                        const regimeLeft    = getRegime(tf, pane);
                        const regStateLeft  = REGIME_STATE_LEFT[regimeLeft] || {};

                        applyStateAndRenderLeft(tfLeft, stateLeft, {
                            autoY: false,
                            yRangeOverride: regStateLeft.yRange
                        });
                    }
                }
            }

            // Auto-Selection-Logik
            if (
                !isLeft &&
                VIEW_MODE === VIEW_MODE_SPLIT &&
                (HTF_BEHAVIOR === HTF_BEHAVIOR_INDEPENDENT ||
                 HTF_BEHAVIOR === HTF_BEHAVIOR_FOLLOW_SNAP)
            ) {
                const setupSelectEl = document.getElementById("setup-select");
                if (setupSelectEl && !HTF_SNAPSHOT_ACTIVE && !setupSelectEl.value) {
                    const bestSetup = autoSelectSetupForCurrentView(tfData, state, excludedSetupId);
                    if (bestSetup) {
                        setupSelectEl.value = String(bestSetup.id);

                        if (bestSetup.signalTs != null && Number.isFinite(bestSetup.signalTs)) {
                            HTF_SNAPSHOT_MAX_SIGNAL_TS =
                                bestSetup.signalTs + PHASE2_SIGNAL_BASE_MINUTES * 60 * 1000;
                        } else {
                            HTF_SNAPSHOT_MAX_SIGNAL_TS = null;
                        }

                        applyHtfSnapshotForSetup(bestSetup, {
                            preserveView: false,
                            isAutoPan: true
                        });
                    }
                }
            }

            // HTF-Follow-Update
            if (!isLeft && VIEW_MODE === VIEW_MODE_SPLIT && !HTF_SNAPSHOT_ACTIVE) {
                if (HTF_BEHAVIOR === HTF_BEHAVIOR_FOLLOW_SNAP ||
                    HTF_BEHAVIOR === HTF_BEHAVIOR_FOLLOW_STRICT) {
                    updateHtfFollowFromLtf(state);
                }
            }
        }

        function handleRelayoutingForPane(pane, ev) {
            if (isRelayoutFromCode) return;
            if (!DATA) return;
            const isLeft = (pane === "left");
            const tf = isLeft ? currentTfLeft : currentTf;

            const tfData = DATA.timeframes[tf];
            if (!tfData) return;

            const regime = getRegime(tf);
            const regStateAll = isLeft ? REGIME_STATE_LEFT : REGIME_STATE;
            const regState = regStateAll[regime];

            let hasX = false;
            let v0 = null, v1 = null;

            if (ev["xaxis.range[0]"] !== undefined && ev["xaxis.range[1]"] !== undefined) {
                v0 = parseFloat(ev["xaxis.range[0]"]);
                v1 = parseFloat(ev["xaxis.range[1]"]);
                if (isFinite(v0) && isFinite(v1)) hasX = true;
            }

            let state = isLeft ? TF_STATE_LEFT[tf] : TF_STATE[tf];
            if (!state) {
                state = computeWindowForTf(tfData, DEFAULT_VISIBLE_BARS, null);
            }

            if (hasX) {
                const minIdx = tfData.minIdx;
                const maxIdx = tfData.maxIdx;

                // Rohes View-Fenster von Plotly
                let viewStart = v0;
                let viewEnd   = v1;

                if (!isFinite(viewStart) || !isFinite(viewEnd)) {
                    viewStart = state.viewStart != null ? state.viewStart : (minIdx - 0.5);
                    viewEnd   = state.viewEnd   != null ? state.viewEnd   : (maxIdx + 0.5);
                }

                const dataBandStart = minIdx - 0.5;
                const dataBandEnd   = maxIdx + 0.5;

                let span = Math.abs(viewEnd - viewStart);
                if (span < 1e-6) span = 1;

                if (viewStart > dataBandEnd) {
                    viewEnd = dataBandEnd;
                    viewStart = viewEnd - span;
                } else if (viewEnd < dataBandStart) {
                    viewStart = dataBandStart;
                    viewEnd = viewStart + span;
                }

                if (viewStart === viewEnd) viewEnd = viewStart + 1;

                const vLeft  = Math.min(viewStart, viewEnd);
                const vRight = Math.max(viewStart, viewEnd);

                let left  = Math.max(vLeft,  dataBandStart);
                let right = Math.min(vRight, dataBandEnd);

                if (right >= left) {
                    let visibleStartIdx = left + 0.5;
                    let visibleEndIdx   = right - 0.5;
                    if (visibleEndIdx < visibleStartIdx) {
                        const tmp = visibleStartIdx;
                        visibleStartIdx = visibleEndIdx;
                        visibleEndIdx = tmp;
                    }

                    const approxVisibleBars = Math.max(
                        1,
                        Math.round(visibleEndIdx - visibleStartIdx + 1)
                    );
                    const centerIdx = 0.5 * (visibleStartIdx + visibleEndIdx);

                    let baseState = computeWindowForTf(tfData, approxVisibleBars, centerIdx);

                    baseState.visibleStartIdx = visibleStartIdx;
                    baseState.visibleEndIdx   = visibleEndIdx;
                    baseState.visibleBars     = Math.max(
                        1,
                        visibleEndIdx - visibleStartIdx + 1
                    );

                    baseState.viewStart = viewStart;
                    baseState.viewEnd   = viewEnd;

                    state = baseState;
                } else {
                    state.viewStart = viewStart;
                    state.viewEnd   = viewEnd;
                }
            }

            // State nur merken – NICHT den rechten Chart neu rendern
            if (isLeft) {
                TF_STATE_LEFT[tf] = state;
            } else {
                TF_STATE[tf] = state;
            }

            // timeRange/anchorTime updaten (für Regime-Logik)
            if (state.visibleStartIdx != null && state.visibleEndIdx != null) {
                const bars = tfData.bars || [];
                const minIdx = tfData.minIdx;

                const posL = Math.max(0, state.visibleStartIdx - minIdx);
                const posR = Math.min(bars.length - 1, state.visibleEndIdx - minIdx);

                if (bars[posL] && bars[posR]) {
                    regState.timeRange = [bars[posL].t, bars[posR].t];
                    regState.anchorTime = bars[posR].t;
                }
                regState.visibleBarsHint = state.visibleBars;
            }

            // Nur rechter Chart + Follow-Modi: live HTF neu aggregieren
            if (
                !isLeft &&
                VIEW_MODE === VIEW_MODE_SPLIT &&
                (HTF_BEHAVIOR === HTF_BEHAVIOR_FOLLOW_SNAP ||
                HTF_BEHAVIOR === HTF_BEHAVIOR_FOLLOW_STRICT)
            ) {
                updateHtfFollowFromLtf(state);
            }
        }

        // LIGHT VERSION - in HTF follows LTF Modi werden die HTF Candles nur NACH Pan aktualisiert
        function bindPlotlyEventsOnce() {
            const rightEl = document.getElementById("m1-chart");
            if (rightEl && typeof rightEl.on === "function" && !plotlyEventsBoundRight) {
                rightEl.on("plotly_relayout", (ev) => handleRelayoutForPane("right", ev));
                plotlyEventsBoundRight = true;
            }

            const leftEl = document.getElementById("htf-chart");
            if (leftEl && typeof leftEl.on === "function" && !plotlyEventsBoundLeft) {
                leftEl.on("plotly_relayout", (ev) => handleRelayoutForPane("left", ev));
                plotlyEventsBoundLeft = true;
            }
        }

        // HEAVY VERSION - in HTF follows LTF Modi werden die HTF Candles WÄHREND des Pans aktualisiert
        /*function bindPlotlyEventsOnce() {
            const rightEl = document.getElementById("m1-chart");
            if (rightEl && typeof rightEl.on === "function" && !plotlyEventsBoundRight) {
                rightEl.on("plotly_relayout", (ev) => handleRelayoutForPane("right", ev));
                // NEU: live während des Pannens
                rightEl.on("plotly_relayouting", (ev) => handleRelayoutingForPane("right", ev));
                plotlyEventsBoundRight = true;
            }

            const leftEl = document.getElementById("htf-chart");
            if (leftEl && typeof leftEl.on === "function" && !plotlyEventsBoundLeft) {
                leftEl.on("plotly_relayout", (ev) => handleRelayoutForPane("left", ev));
                // Falls du auch im linken Chart live etwas machen willst:
                // leftEl.on("plotly_relayouting", (ev) => handleRelayoutingForPane("left", ev));
                plotlyEventsBoundLeft = true;
            }
        }*/


        // -----------------------------------------------------------
        // 9) UI-Events (Hover & Axis Mode)
        // -----------------------------------------------------------

        function syncUiToState() {
            // Timeframe-Auswahl (Dropdown, rechter Chart)
            const tfSelect = document.getElementById("tf-select");
            if (tfSelect) {
                tfSelect.value = currentTf;
            }

            // HTF-Timeframe-Auswahl (Dropdown, linker Chart)
            const tfSelectLeft = document.getElementById("tf-select-left");
            if (tfSelectLeft) {
                tfSelectLeft.value = currentTfLeft;
            }

            // Candle-Hover
            const hoverToggle = document.getElementById("candle-hover-toggle");
            if (hoverToggle) {
                hoverToggle.checked = !!candleHoverOn;
            }

            // Session-Tage Input
            const sessionInput = document.getElementById("session-days");
            if (sessionInput) {
                sessionInput.value = String(sessionDays);
            }

            // Show Misses
            const showMissesToggle = document.getElementById("show-misses-toggle");
            if (showMissesToggle) {
                showMissesToggle.checked = !!SHOW_MISSES;
            }

            // Show Signals
            const showSignalsToggle = document.getElementById("show-signals-toggle");
            if (showSignalsToggle) {
                showSignalsToggle.checked = !!SHOW_SIGNALS;
            }

            // Setup-Sortierung
            const setupSortSelect = document.getElementById("setup-sort-select");
            if (setupSortSelect) {
                setupSortSelect.value = SETUP_SORT_MODE;
            }

            // View-Mode
            const viewModeInputs = document.querySelectorAll('#view-mode input[name="view-mode"]');
            viewModeInputs.forEach((input) => {
                input.checked = (input.value === VIEW_MODE);
            });

            // HTF-Behavior
            const htfBehaviorSelect = document.getElementById("htf-behavior-select");
            if (htfBehaviorSelect) {
                htfBehaviorSelect.value = HTF_BEHAVIOR;
            }
        }

        function onCandleHoverToggle(checked) {
            candleHoverOn = checked;
            const hoverInfoValue = candleHoverOn ? "x+y" : "none";

            // den/die Candlestick-Traces dynamisch finden
            const gd = document.getElementById("m1-chart");
            if (gd && gd.data && gd.data.length) {
                const candleIndices = [];
                gd.data.forEach((tr, idx) => {
                    if (tr && tr.type === "candlestick") {
                        candleIndices.push(idx);
                    }
                });

                if (candleIndices.length) {
                    Plotly.restyle("m1-chart", { hoverinfo: hoverInfoValue }, candleIndices);
                }
            }

            savePersistentState();
        }

        function onHtfBehaviorChange(newBehavior) {
            if (
                newBehavior !== HTF_BEHAVIOR_INDEPENDENT &&
                newBehavior !== HTF_BEHAVIOR_FOLLOW_SNAP &&
                newBehavior !== HTF_BEHAVIOR_FOLLOW_STRICT
            ) {
                return;
            }

            if (HTF_BEHAVIOR === newBehavior) {
                const sel = document.getElementById("htf-behavior-select");
                if (sel) sel.value = HTF_BEHAVIOR;
                return;
            }

            HTF_BEHAVIOR = newBehavior;

            // In strikt folgendem Modus keine Setup-Snapshots
            if (HTF_BEHAVIOR === HTF_BEHAVIOR_FOLLOW_STRICT) {
                clearHtfSnapshot({ clearSetupSelect: false });
            }

            if (HTF_BEHAVIOR === HTF_BEHAVIOR_INDEPENDENT) {
                // Follow-View deaktivieren, auf originale HTF-Daten zurück
                HTF_FOLLOW_ACTIVE = false;
                HTF_FOLLOW_TFDATA = null;
                HTF_FOLLOW_INFO   = null;

                if (VIEW_MODE === VIEW_MODE_SPLIT && DATA && DATA.timeframes[currentTfLeft]) {
                    const tfDataL = DATA.timeframes[currentTfLeft];
                    let stateL = TF_STATE_LEFT[currentTfLeft];
                    if (!stateL) {
                        stateL = computeWindowForTfRightAnchored(
                            tfDataL,
                            DEFAULT_VISIBLE_BARS,
                            tfDataL.maxIdx
                        );
                    }
                    const regimeL   = getRegime(currentTfLeft, "left");
                    const regStateL = REGIME_STATE_LEFT[regimeL] || {};
                    applyStateAndRenderLeft(currentTfLeft, stateL, {
                        autoY: false,
                        yRangeOverride: regStateL.yRange
                    });
                }
            } else {
                // Follow-Modi: sofort einen Follow-Snapshot auf Basis des aktuellen LTF-States bauen
                if (VIEW_MODE === VIEW_MODE_SPLIT && TF_STATE[currentTf]) {
                    updateHtfFollowFromLtf(TF_STATE[currentTf]);
                }
            }

            savePersistentState();
        }

        function onViewModeChange(mode) {
            if (mode !== VIEW_MODE_SINGLE && mode !== VIEW_MODE_SPLIT) {
                return;
            }

            const oldMode = VIEW_MODE;
            if (oldMode === mode) {
                // Radios ggf. nur syncen
                const inputsSame = document.querySelectorAll('#view-mode input[name="view-mode"]');
                inputsSame.forEach((input) => {
                    input.checked = (input.value === mode);
                });
                return;
            }

            VIEW_MODE = mode;

            // Im Single-View keinen HTF-Snapshot verwenden
            if (mode === VIEW_MODE_SINGLE) {
                clearHtfSnapshot();
            }

            // Radios synchronisieren
            const inputs = document.querySelectorAll('#view-mode input[name="view-mode"]');
            inputs.forEach((input) => {
                input.checked = (input.value === mode);
            });

            // Layout (Flex 100% → 50/50 bzw. zurück) anpassen
            updateLayoutForViewMode();

            // Nach dem Layout-Wechsel einen Frame warten,
            // damit der Browser die neuen Breiten berechnet hat
            window.requestAnimationFrame(() => {
                // Faktor für sichtbare Bars:
                // single -> split  => halb so viele Bars
                // split  -> single => doppelt so viele Bars
                let factor = 1;
                if (oldMode === VIEW_MODE_SINGLE && mode === VIEW_MODE_SPLIT) {
                    factor = 0.5;
                } else if (oldMode === VIEW_MODE_SPLIT && mode === VIEW_MODE_SINGLE) {
                    factor = 2.0;
                }

                // Rechten Chart neu an rechten Rand anpassen
                reanchorRightChartToRightEdge(factor);

                // In Follow-Modi direkt danach den HTF-Follow-Snapshot aktualisieren
                if (
                    VIEW_MODE === VIEW_MODE_SPLIT &&
                    (HTF_BEHAVIOR === HTF_BEHAVIOR_FOLLOW_SNAP ||
                     HTF_BEHAVIOR === HTF_BEHAVIOR_FOLLOW_STRICT) &&
                    TF_STATE[currentTf]
                ) {
                    updateHtfFollowFromLtf(TF_STATE[currentTf]);
                }

                // Plotly zwingen, die neue Container-Breite in Pixel zu übernehmen
                try {
                    Plotly.Plots.resize("m1-chart");
                    if (VIEW_MODE === VIEW_MODE_SPLIT) {
                        Plotly.Plots.resize("htf-chart");
                    }
                } catch (e) {
                    console.warn("Plotly resize nach ViewMode-Change fehlgeschlagen:", e);
                }

                savePersistentState();
            });
        }

        function onAxisModeChange(mode) {
            // Globale Info (wird auch beim Build der Layouts benutzt)
            axisMode = mode;

            const update = {};
            if (mode === "both") {
                update["xaxis.fixedrange"] = false;
                update["yaxis.fixedrange"] = false;
            } else if (mode === "x") {
                update["xaxis.fixedrange"] = false;
                update["yaxis.fixedrange"] = true;
            } else if (mode === "y") {
                update["xaxis.fixedrange"] = true;
                update["yaxis.fixedrange"] = false;
            }

            // Immer: rechten (LTF) Chart anpassen
            try {
                Plotly.relayout("m1-chart", update);
            } catch (e) {
                // ist ok, falls Chart noch nicht existiert
            }

            // Zusätzlich: linken (HTF) Chart, falls vorhanden,
            // damit Shift/Alt dort SOFORT greifen.
            try {
                const htfEl = document.getElementById("htf-chart");
                if (htfEl && VIEW_MODE === VIEW_MODE_SPLIT) {
                    Plotly.relayout("htf-chart", update);
                }
            } catch (e) {
                // ignorieren – z.B. wenn noch kein HTF gerendert ist
            }

            savePersistentState();
        }

        // Sobald ein anderer Tab STORAGE_KEY neu schreibt, Ansicht live nachziehen
        window.addEventListener("storage", (ev) => {
            try {
                if (ev.key === STORAGE_KEY) {
                    // nur reagieren, wenn wir DATA schon haben
                    if (DATA) {
                        reapplyStateFromStorage();
                    }
                }
            } catch (e) {
                console.warn("[restart] storage-listener error:", e);
            }
        });


        // -----------------------------------------------------------
        // 10) Init
        // -----------------------------------------------------------
        document.addEventListener("DOMContentLoaded", async () => {
            initSplitterDrag();

            buildTfSelects();

            const hoverToggle = document.getElementById("candle-hover-toggle");
            hoverToggle.addEventListener("change", (e) => {
                onCandleHoverToggle(e.target.checked);
            });

            const showMissesToggle = document.getElementById("show-misses-toggle");
            if (showMissesToggle) {
                showMissesToggle.checked = SHOW_MISSES;
                showMissesToggle.addEventListener("change", (e) => {
                    SHOW_MISSES = !!e.target.checked;
                    rebuildSetupsList();
                    rerenderCurrentViewWithPhases();
                    savePersistentState();
                });
            }

            const showSignalsToggle = document.getElementById("show-signals-toggle");
            if (showSignalsToggle) {
                showSignalsToggle.checked = SHOW_SIGNALS;
                showSignalsToggle.addEventListener("change", (e) => {
                    SHOW_SIGNALS = !!e.target.checked;
                    rerenderCurrentViewWithPhases();
                    savePersistentState();
                });
            }

            const viewModeContainer = document.getElementById("view-mode");
            if (viewModeContainer) {
                viewModeContainer.addEventListener("change", (e) => {
                    if (e.target && e.target.name === "view-mode") {
                        onViewModeChange(e.target.value);
                    }
                });
            }

            const htfBehaviorSelect = document.getElementById("htf-behavior-select");
            if (htfBehaviorSelect) {
                htfBehaviorSelect.value = HTF_BEHAVIOR;
                htfBehaviorSelect.addEventListener("change", (e) => {
                    onHtfBehaviorChange(e.target.value);
                });
            }


            const sessionDaysInput = document.getElementById("session-days");
            if (sessionDaysInput) {
                sessionDaysInput.value = String(sessionDays);
                sessionDaysInput.addEventListener("change", (e) => {
                    let val = parseInt(e.target.value, 10);
                    if (!Number.isFinite(val) || val < 3) val = 3;   // MIN 3
                    if (val > 60) val = 60;
                    sessionDays = val;
                    e.target.value = String(sessionDays);

                    if (!DATA) {
                        savePersistentState();
                        return;
                    }
                    const tfData = DATA.timeframes[currentTf];
                    if (!tfData) {
                        savePersistentState();
                        return;
                    }

                    let state = TF_STATE[currentTf];
                    if (!state) {
                        state = computeWindowForTf(tfData, DEFAULT_VISIBLE_BARS, null);
                    }
                    const regime = getRegime(currentTf);
                    const regState = REGIME_STATE[regime] || {};

                    applyStateAndRender(currentTf, state, {
                        autoY: false,
                        yRangeOverride: regState.yRange
                    });

                    savePersistentState();
                });
            }

            // Phase2 / Phase3 Dropdown-Events
            const phase2Select = document.getElementById("phase2-file-select");
            const phase3Select = document.getElementById("phase3-file-select");
            const setupSelect  = document.getElementById("setup-select");
            const setupSortSelect = document.getElementById("setup-sort-select");

            if (phase2Select) {
                phase2Select.addEventListener("change", async (e) => {
                    phase2File = e.target.value || null;
                    await loadPhase2File(phase2File);
                    rerenderCurrentViewWithPhases();
                    rebuildSetupsList();
                });
            }

            if (phase3Select) {
                phase3Select.addEventListener("change", async (e) => {
                    phase3File = e.target.value || null;
                    await loadPhase3File(phase3File);
                    rerenderCurrentViewWithPhases();
                    rebuildSetupsList();
                });
            }

            // NEU: Setup-Auswahl
            if (setupSelect) {
                setupSelect.addEventListener("change", (e) => {
                    const id = e.target.value;
                    if (!id) return;
                    const setup = SETUP_BY_ID[id];
                    if (!setup) return;
                    focusOnSetup(setup);
                });
            }

            if (setupSortSelect) {
                setupSortSelect.value = SETUP_SORT_MODE;
                setupSortSelect.addEventListener("change", (e) => {
                    SETUP_SORT_MODE = e.target.value || "time_asc";
                    renderSetupDropdown();
                    savePersistentState();
                });
            }

            try {
                DATA = await loadData();

                const restored = restorePersistentState();

                if (!DATA.timeframes[currentTf]) {
                    const available = Object.keys(DATA.timeframes);
                    if (available.length > 0) {
                        currentTf = available[0];
                    }
                }
                if (!DATA.timeframes[currentTfLeft]) {
                    const available = Object.keys(DATA.timeframes);
                    if (available.length > 0) {
                        currentTfLeft = available[0];
                    }
                }

                syncUiToState();

                // Rechter (LTF) Chart
                if (restored && TF_STATE[currentTf]) {
                    const regimeR = getRegime(currentTf);
                    const regStateR = REGIME_STATE[regimeR] || {};
                    const tfStateR = TF_STATE[currentTf];

                    applyStateAndRender(currentTf, tfStateR, {
                        autoY: false,
                        yRangeOverride: regStateR.yRange
                    });
                } else {
                    initDefaultViewRight();
                }

                // Layout (Single vs. HTF/LTF) anhand des persistenten VIEW_MODE setzen
                updateLayoutForViewMode();   // initialisiert ggf. linken Chart & bindet Events

                // Events explizit binden (ist idempotent, aber ok)
                bindPlotlyEventsOnce();

                // Wenn Seite bereits im Split-View geladen wird:
                if (VIEW_MODE === VIEW_MODE_SPLIT) {
                    // nur noch resizen, Layout ist ja schon gesetzt
                    window.requestAnimationFrame(() => {
                        try {
                            Plotly.Plots.resize("m1-chart");
                            Plotly.Plots.resize("htf-chart");
                        } catch (e) {
                            console.warn("Initial Plotly resize im Split-Mode fehlgeschlagen:", e);
                        }
                    });
                }

                rebuildSetupsList();
                startPhaseScanLoop();

                // Initial HTF-Follow-Snapshot setzen, falls Modus 2 oder 3 aktiv ist
                if (
                    VIEW_MODE === VIEW_MODE_SPLIT &&
                    (HTF_BEHAVIOR === HTF_BEHAVIOR_FOLLOW_SNAP ||
                     HTF_BEHAVIOR === HTF_BEHAVIOR_FOLLOW_STRICT) &&
                    TF_STATE[currentTf]
                ) {
                    updateHtfFollowFromLtf(TF_STATE[currentTf]);
                }

                // --- Keyboard Navigation für Setups (global) ---
                document.addEventListener("keydown", (e) => {
                    const tag = (e.target && e.target.tagName)
                        ? e.target.tagName.toLowerCase()
                        : "";

                    // In Textfeldern nicht stören
                    if (tag === "input" || tag === "textarea") return;

                    const key = (e.key || "").toLowerCase();
                    const nextKeys = ["arrowdown", "pagedown", "arrowright"];
                    const prevKeys = ["arrowup", "pageup", "arrowleft"];

                    if (!nextKeys.includes(key) && !prevKeys.includes(key)) {
                        return;
                    }

                    const setups = getSortedSetups();
                    if (!setups.length) return;

                    const setupSelectEl = document.getElementById("setup-select");
                    if (!setupSelectEl) return;

                    const currentId = setupSelectEl.value;
                    let idx = setups.findIndex((s) => String(s.id) === currentId);

                    // Wenn noch kein Setup ausgewählt ist -> erstes Setup
                    if (idx === -1) {
                        idx = 0;
                    } else if (nextKeys.includes(key)) {
                        if (idx < setups.length - 1) idx++;
                    } else if (prevKeys.includes(key)) {
                        if (idx > 0) idx--;
                    }

                    const setup = setups[idx];
                    if (!setup) return;

                    setupSelectEl.value = String(setup.id);
                    focusOnSetup(setup);

                    // Browser-Scroll (PageUp/Down) unterdrücken
                    e.preventDefault();
                });

                // --- Window-Resize: Ticks dynamisch an Chartbreite anpassen ---
                let resizeRerenderTimer = null;
                window.addEventListener("resize", () => {
                    if (!DATA) return;
                    if (resizeRerenderTimer) {
                        clearTimeout(resizeRerenderTimer);
                    }
                    resizeRerenderTimer = setTimeout(() => {
                        try {
                            rerenderCurrentViewWithPhases();
                        } catch (e) {
                            console.warn("Error re-rendering after resize:", e);
                        }
                    }, 150);
                });
            } catch (err) {
                console.error(err);
                alert("Error loading data.json. Check console.");
            }
        });
    </script>
</body>
</html>
